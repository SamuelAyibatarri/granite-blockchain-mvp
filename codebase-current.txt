./codebase-current.txt
---


---
./codebase.txt
---
./codebase.txt
---


---
./package-lock.json
---
{
  "name": "granite-blockchain-mvp",
  "version": "0.0.1",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "granite-blockchain-mvp",
      "version": "0.0.1",
      "license": "ISC",
      "dependencies": {
        "@hono/node-server": "^1.19.5",
        "@types/elliptic": "^6.4.18",
        "base-x": "^5.0.1",
        "better-sqlite3": "^12.4.1",
        "bignumber.js": "^9.3.1",
        "crypto-js": "^4.2.0",
        "elliptic": "^6.6.1",
        "hono": "^4.10.2",
        "openpgp": "^6.2.2"
      },
      "devDependencies": {
        "@types/better-sqlite3": "^7.6.13",
        "@types/crypto-js": "^4.2.2",
        "@types/node": "^24.5.2"
      }
    },
    "node_modules/@hono/node-server": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@hono/node-server/-/node-server-1.19.5.tgz",
      "integrity": "sha512-iBuhh+uaaggeAuf+TftcjZyWh2GEgZcVGXkNtskLVoWaXhnJtC5HLHrU8W1KHDoucqO1MswwglmkWLFyiDn4WQ==",
      "engines": {
        "node": ">=18.14.1"
      },
      "peerDependencies": {
        "hono": "^4"
      }
    },
    "node_modules/@types/better-sqlite3": {
      "version": "7.6.13",
      "resolved": "https://registry.npmmirror.com/@types/better-sqlite3/-/better-sqlite3-7.6.13.tgz",
      "integrity": "sha512-NMv9ASNARoKksWtsq/SHakpYAYnhBrQgGD8zkLYk/jaK8jUGn08CfEdTRgYhMypUQAfzSP8W6gNLe0q19/t4VA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmmirror.com/@types/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-DLbJ1BPqxvQhIGbeu8VbUC1DiAiahHtAYvA0ZEAa4P31F7IaArc8z3C3BRQdWX4mtLQuABG4yzp76ZrS02Ui1Q==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/crypto-js": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/@types/crypto-js/-/crypto-js-4.2.2.tgz",
      "integrity": "sha512-sDOLlVbHhXpAUAL0YHDUUwDZf3iN4Bwi4W6a0W0b+QcAezUbRtH4FVb+9J4h+XFPW7l/gQ9F8qC7P+Ec4k8QVQ==",
      "dev": true
    },
    "node_modules/@types/elliptic": {
      "version": "6.4.18",
      "resolved": "https://registry.npmmirror.com/@types/elliptic/-/elliptic-6.4.18.tgz",
      "integrity": "sha512-UseG6H5vjRiNpQvrhy4VF/JXdA3V/Fp5amvveaL+fs28BZ6xIKJBPnUPRlEaZpysD9MbpfaLi8lbl7PGUAkpWw==",
      "license": "MIT",
      "dependencies": {
        "@types/bn.js": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "24.5.2",
      "resolved": "https://registry.npmmirror.com/@types/node/-/node-24.5.2.tgz",
      "integrity": "sha512-FYxk1I7wPv3K2XBaoyH2cTnocQEu8AOZ60hPbsyukMPLv5/5qr7V1i8PLHdl6Zf87I+xZXFvPCXYjiTFq+YSDQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.12.0"
      }
    },
    "node_modules/base-x": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-5.0.1.tgz",
      "integrity": "sha512-M7uio8Zt++eg3jPj+rHMfCC+IuygQHHCOU+IYsVtik6FWjuYpVt/+MRKcgsAMHh8mMFAwnB+Bs+mTrFiXjMzKg==",
      "license": "MIT"
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmmirror.com/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/better-sqlite3": {
      "version": "12.4.1",
      "resolved": "https://registry.npmmirror.com/better-sqlite3/-/better-sqlite3-12.4.1.tgz",
      "integrity": "sha512-3yVdyZhklTiNrtg+4WqHpJpFDd+WHTg2oM7UcR80GqL05AOV0xEJzc6qNvFYoEtE+hRp1n9MpN6/+4yhlGkDXQ==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "bindings": "^1.5.0",
        "prebuild-install": "^7.1.1"
      },
      "engines": {
        "node": "20.x || 22.x || 23.x || 24.x"
      }
    },
    "node_modules/bignumber.js": {
      "version": "9.3.1",
      "resolved": "https://registry.npmmirror.com/bignumber.js/-/bignumber.js-9.3.1.tgz",
      "integrity": "sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==",
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmmirror.com/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "license": "MIT",
      "dependencies": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "node_modules/bl": {
      "version": "4.1.0",
      "resolved": "https://registry.npmmirror.com/bl/-/bl-4.1.0.tgz",
      "integrity": "sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==",
      "license": "MIT",
      "dependencies": {
        "buffer": "^5.5.0",
        "inherits": "^2.0.4",
        "readable-stream": "^3.4.0"
      }
    },
    "node_modules/bn.js": {
      "version": "4.12.2",
      "resolved": "https://registry.npmmirror.com/bn.js/-/bn.js-4.12.2.tgz",
      "integrity": "sha512-n4DSx829VRTRByMRGdjQ9iqsN0Bh4OolPsFnaZBLcbi8iXcB+kJ9s7EnRt4wILZNV3kPLHkRVfOc/HvhC3ovDw==",
      "license": "MIT"
    },
    "node_modules/brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w==",
      "license": "MIT"
    },
    "node_modules/buffer": {
      "version": "5.7.1",
      "resolved": "https://registry.npmmirror.com/buffer/-/buffer-5.7.1.tgz",
      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.1.13"
      }
    },
    "node_modules/chownr": {
      "version": "1.1.4",
      "resolved": "https://registry.npmmirror.com/chownr/-/chownr-1.1.4.tgz",
      "integrity": "sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==",
      "license": "ISC"
    },
    "node_modules/crypto-js": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/crypto-js/-/crypto-js-4.2.0.tgz",
      "integrity": "sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q=="
    },
    "node_modules/decompress-response": {
      "version": "6.0.0",
      "resolved": "https://registry.npmmirror.com/decompress-response/-/decompress-response-6.0.0.tgz",
      "integrity": "sha512-aW35yZM6Bb/4oJlZncMH2LCoZtJXTRxES17vE3hoRiowU2kWHaJKFkSBDnDR+cm9J+9QhXmREyIfv0pji9ejCQ==",
      "license": "MIT",
      "dependencies": {
        "mimic-response": "^3.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/deep-extend": {
      "version": "0.6.0",
      "resolved": "https://registry.npmmirror.com/deep-extend/-/deep-extend-0.6.0.tgz",
      "integrity": "sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA==",
      "license": "MIT",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.1.1",
      "resolved": "https://registry.npmmirror.com/detect-libc/-/detect-libc-2.1.1.tgz",
      "integrity": "sha512-ecqj/sy1jcK1uWrwpR67UhYrIFQ+5WlGxth34WquCbamhFA6hkkwiu37o6J5xCHdo1oixJRfVRw+ywV+Hq/0Aw==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/elliptic": {
      "version": "6.6.1",
      "resolved": "https://registry.npmmirror.com/elliptic/-/elliptic-6.6.1.tgz",
      "integrity": "sha512-RaddvvMatK2LJHqFJ+YA4WysVN5Ita9E35botqIYspQ4TkRAlCicdzKOjlyv/1Za5RyTNn7di//eEV0uTAfe3g==",
      "license": "MIT",
      "dependencies": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/end-of-stream": {
      "version": "1.4.5",
      "resolved": "https://registry.npmmirror.com/end-of-stream/-/end-of-stream-1.4.5.tgz",
      "integrity": "sha512-ooEGc6HP26xXq/N+GCGOT0JKCLDGrq2bQUZrQ7gyrJiZANJ/8YDTxTpQBXGMn+WbIQXNVpyWymm7KYVICQnyOg==",
      "license": "MIT",
      "dependencies": {
        "once": "^1.4.0"
      }
    },
    "node_modules/expand-template": {
      "version": "2.0.3",
      "resolved": "https://registry.npmmirror.com/expand-template/-/expand-template-2.0.3.tgz",
      "integrity": "sha512-XYfuKMvj4O35f/pOXLObndIRvyQ+/+6AhODh+OKWj9S9498pHHn/IMszH+gt0fBCRWMNfk1ZSp5x3AifmnI2vg==",
      "license": "(MIT OR WTFPL)",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==",
      "license": "MIT"
    },
    "node_modules/fs-constants": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/fs-constants/-/fs-constants-1.0.0.tgz",
      "integrity": "sha512-y6OAwoSIf7FyjMIv94u+b5rdheZEjzR63GTyZJm5qh4Bi+2YgwLCcI/fPFZkL5PSixOt6ZNKm+w+Hfp/Bciwow==",
      "license": "MIT"
    },
    "node_modules/github-from-package": {
      "version": "0.0.0",
      "resolved": "https://registry.npmmirror.com/github-from-package/-/github-from-package-0.0.0.tgz",
      "integrity": "sha512-SyHy3T1v2NUXn29OsWdxmK6RwHD+vkj3v8en8AOBZ1wBQ/hCAQ5bAQTD02kW4W9tUp/3Qh6J8r9EvntiyCmOOw==",
      "license": "MIT"
    },
    "node_modules/hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmmirror.com/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "node_modules/hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "license": "MIT",
      "dependencies": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/hono": {
      "version": "4.10.4",
      "resolved": "https://registry.npmjs.org/hono/-/hono-4.10.4.tgz",
      "integrity": "sha512-YG/fo7zlU3KwrBL5vDpWKisLYiM+nVstBQqfr7gCPbSYURnNEP9BDxEMz8KfsDR9JX0lJWDRNc6nXX31v7ZEyg==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=16.9.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmmirror.com/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmmirror.com/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ini": {
      "version": "1.3.8",
      "resolved": "https://registry.npmmirror.com/ini/-/ini-1.3.8.tgz",
      "integrity": "sha512-JV/yugV2uzW5iMRSiZAyDtQd+nxtUnjeLt0acNdw98kKLrvuRVyB80tsREOE7yvGVgalhZ6RNXCmEHkUKBKxew==",
      "license": "ISC"
    },
    "node_modules/mimic-response": {
      "version": "3.1.0",
      "resolved": "https://registry.npmmirror.com/mimic-response/-/mimic-response-3.1.0.tgz",
      "integrity": "sha512-z0yWI+4FDrrweS8Zmt4Ej5HdJmky15+L2e6Wgn3+iK5fWzb6T3fhNFq2+MeTRb064c6Wr4N/wv0DzQTjNzHNGQ==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A==",
      "license": "ISC"
    },
    "node_modules/minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg==",
      "license": "MIT"
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmmirror.com/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/mkdirp-classic": {
      "version": "0.5.3",
      "resolved": "https://registry.npmmirror.com/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
      "integrity": "sha512-gKLcREMhtuZRwRAfqP3RFW+TK4JqApVBtOIftVgjuABpAtpxhPGaDcfvbhNvD0B8iD1oUr/txX35NjcaY6Ns/A==",
      "license": "MIT"
    },
    "node_modules/napi-build-utils": {
      "version": "2.0.0",
      "resolved": "https://registry.npmmirror.com/napi-build-utils/-/napi-build-utils-2.0.0.tgz",
      "integrity": "sha512-GEbrYkbfF7MoNaoh2iGG84Mnf/WZfB0GdGEsM8wz7Expx/LlWf5U8t9nvJKXSp3qr5IsEbK04cBGhol/KwOsWA==",
      "license": "MIT"
    },
    "node_modules/node-abi": {
      "version": "3.77.0",
      "resolved": "https://registry.npmmirror.com/node-abi/-/node-abi-3.77.0.tgz",
      "integrity": "sha512-DSmt0OEcLoK4i3NuscSbGjOf3bqiDEutejqENSplMSFA/gmB8mkED9G4pKWnPl7MDU4rSHebKPHeitpDfyH0cQ==",
      "license": "MIT",
      "dependencies": {
        "semver": "^7.3.5"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmmirror.com/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/openpgp": {
      "version": "6.2.2",
      "resolved": "https://registry.npmmirror.com/openpgp/-/openpgp-6.2.2.tgz",
      "integrity": "sha512-P/dyEqQ3gfwOCo+xsqffzXjmUhGn4AZTOJ1LCcN21S23vAk+EAvMJOQTsb/C8krL6GjOSBxqGYckhik7+hneNw==",
      "license": "LGPL-3.0+",
      "engines": {
        "node": ">= 18.0.0"
      }
    },
    "node_modules/prebuild-install": {
      "version": "7.1.3",
      "resolved": "https://registry.npmmirror.com/prebuild-install/-/prebuild-install-7.1.3.tgz",
      "integrity": "sha512-8Mf2cbV7x1cXPUILADGI3wuhfqWvtiLA1iclTDbFRZkgRQS0NqsPZphna9V+HyTEadheuPmjaJMsbzKQFOzLug==",
      "license": "MIT",
      "dependencies": {
        "detect-libc": "^2.0.0",
        "expand-template": "^2.0.3",
        "github-from-package": "0.0.0",
        "minimist": "^1.2.3",
        "mkdirp-classic": "^0.5.3",
        "napi-build-utils": "^2.0.0",
        "node-abi": "^3.3.0",
        "pump": "^3.0.0",
        "rc": "^1.2.7",
        "simple-get": "^4.0.0",
        "tar-fs": "^2.0.0",
        "tunnel-agent": "^0.6.0"
      },
      "bin": {
        "prebuild-install": "bin.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/pump": {
      "version": "3.0.3",
      "resolved": "https://registry.npmmirror.com/pump/-/pump-3.0.3.tgz",
      "integrity": "sha512-todwxLMY7/heScKmntwQG8CXVkWUOdYxIvY2s0VWAAMh/nd8SoYiRaKjlr7+iCs984f2P8zvrfWcDDYVb73NfA==",
      "license": "MIT",
      "dependencies": {
        "end-of-stream": "^1.1.0",
        "once": "^1.3.1"
      }
    },
    "node_modules/rc": {
      "version": "1.2.8",
      "resolved": "https://registry.npmmirror.com/rc/-/rc-1.2.8.tgz",
      "integrity": "sha512-y3bGgqKj3QBdxLbLkomlohkvsA8gdAiUQlSBJnBhfn+BPxg4bc62d8TcBW15wavDfgexCgccckhcZvywyQYPOw==",
      "license": "(BSD-2-Clause OR MIT OR Apache-2.0)",
      "dependencies": {
        "deep-extend": "^0.6.0",
        "ini": "~1.3.0",
        "minimist": "^1.2.0",
        "strip-json-comments": "~2.0.1"
      },
      "bin": {
        "rc": "cli.js"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmmirror.com/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmmirror.com/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmmirror.com/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/simple-concat": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/simple-concat/-/simple-concat-1.0.1.tgz",
      "integrity": "sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/simple-get": {
      "version": "4.0.1",
      "resolved": "https://registry.npmmirror.com/simple-get/-/simple-get-4.0.1.tgz",
      "integrity": "sha512-brv7p5WgH0jmQJr1ZDDfKDOSeWWg+OVypG99A/5vYGPqJ6pxiaHLy8nxtFjBA7oMa01ebA9gfh1uMCFqOuXxvA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "decompress-response": "^6.0.0",
        "once": "^1.3.1",
        "simple-concat": "^1.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmmirror.com/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmmirror.com/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/tar-fs": {
      "version": "2.1.4",
      "resolved": "https://registry.npmmirror.com/tar-fs/-/tar-fs-2.1.4.tgz",
      "integrity": "sha512-mDAjwmZdh7LTT6pNleZ05Yt65HC3E+NiQzl672vQG38jIrehtJk/J3mNwIg+vShQPcLF/LV7CMnDW6vjj6sfYQ==",
      "license": "MIT",
      "dependencies": {
        "chownr": "^1.1.1",
        "mkdirp-classic": "^0.5.2",
        "pump": "^3.0.0",
        "tar-stream": "^2.1.4"
      }
    },
    "node_modules/tar-stream": {
      "version": "2.2.0",
      "resolved": "https://registry.npmmirror.com/tar-stream/-/tar-stream-2.2.0.tgz",
      "integrity": "sha512-ujeqbceABgwMZxEJnk2HDY2DlnUZ+9oEcb1KzTVfYHio0UE6dG71n60d8D2I4qNvleWrrXpmjpt7vZeF1LnMZQ==",
      "license": "MIT",
      "dependencies": {
        "bl": "^4.0.3",
        "end-of-stream": "^1.4.1",
        "fs-constants": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^3.1.1"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/tunnel-agent": {
      "version": "0.6.0",
      "resolved": "https://registry.npmmirror.com/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
      "integrity": "sha512-McnNiV1l8RYeY8tBgEpuodCC1mLUdbSN+CYBL7kJsJNInOP8UjDDEwdk6Mw60vdLLrr5NHKZhMAOSrR2NZuQ+w==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/undici-types": {
      "version": "7.12.0",
      "resolved": "https://registry.npmmirror.com/undici-types/-/undici-types-7.12.0.tgz",
      "integrity": "sha512-goOacqME2GYyOZZfb5Lgtu+1IDmAlAEu5xnD3+xTzS10hT0vzpf0SPjkXwAw9Jm+4n/mQGDP3LO8CPbYROeBfQ==",
      "license": "MIT"
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    }
  }
}


---
./package.json
---
{
  "name": "granite-blockchain-mvp",
  "version": "0.0.1",
  "description": "Simple Implementation of the granite blockchain",
  "license": "ISC",
  "author": "Samuel Ayibatarri",
  "type": "commonjs",
  "main": "dist/main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.13",
    "@types/crypto-js": "^4.2.2",
    "@types/node": "^24.5.2"
  },
  "dependencies": {
    "@hono/node-server": "^1.19.5",
    "@types/elliptic": "^6.4.18",
    "base-x": "^5.0.1",
    "better-sqlite3": "^12.4.1",
    "bignumber.js": "^9.3.1",
    "crypto-js": "^4.2.0",
    "elliptic": "^6.6.1",
    "hono": "^4.10.2",
    "openpgp": "^6.2.2"
  }
}


---
./tsconfig.json
---
{
  "compilerOptions": {
    "module": "commonjs",            
    "outDir": "./dist",              
    "moduleResolution": "node",       
    "esModuleInterop": true,          
    "forceConsistentCasingInFileNames": true, 

    "rootDir": "./src",
    "target": "es2020",               
    "lib": ["es2020"],               
    "types": ["node"],

    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": false,   
    "isolatedModules": false,         
    "noUncheckedSideEffectImports": true, 
    "moduleDetection": "force",       
    "skipLibCheck": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  },
  "include": ["src/**/*"],            
  "exclude": ["node_modules", "dist"] 
}

---
./wallet/wallet_data.json
---
{
  "accountDetails": {
    "privateKeyHex": "f8ff9d7a59958c36be56f38dbbcbaa1b53f5b02f60054bde61d7a5bec6a31ed9",
    "address": {
      "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
      "balance": 949,
      "nonce": 650652
    }
  },
  "transactionHistory": {
    "TxIN": [],
    "TxOut": [
      {
        "sender": {
          "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
          "nonce": 650652,
          "balance": 49
        },
        "recipient": {
          "publicKeyHex": "AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
          "balance": 51,
          "nonce": 2959.9349966464183
        },
        "token": {
          "tokenId": "d",
          "name": "granite",
          "contractAddress": "s",
          "ticker": "gran",
          "totalSupply": 1000000000,
          "circulatingSupply": 10
        },
        "value": 50,
        "gasfee": 1,
        "txHash": "328179a13e26d8545eeada0106c056a9cf2a27ba6815aba1e267c5f7e9c55dac",
        "signature": {
          "r": "a83681f43feacc4965266ccdf3a20f298133c4c2312d69f3740e3517bcbfad11",
          "s": "3340e8a7ca192dc68dc739ddf23f76cd90623299f11d490948081514d90608d9"
        }
      },
      {
        "sender": {
          "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
          "nonce": 650652,
          "balance": 28
        },
        "recipient": {
          "publicKeyHex": "AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
          "balance": 21,
          "nonce": 4519.804247427403
        },
        "token": {
          "tokenId": "d",
          "name": "granite",
          "contractAddress": "s",
          "ticker": "gran",
          "totalSupply": 1000000000,
          "circulatingSupply": 10
        },
        "value": 20,
        "gasfee": 1,
        "txHash": "17c2b52a1e07c159f0257ffd97fe0935fa77fc65a6b3d781318883f62aaf500e",
        "signature": {
          "r": "c43c7ca2dff467f3cc87220ad46ece1b10212d8e3a8c4c3951281f79ada25830",
          "s": "434143669c25343da4ca330175f09eb6104bc7bceceefceb2ce6d366d7a4283f"
        }
      },
      {
        "sender": {
          "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
          "nonce": 650652,
          "balance": 949
        },
        "recipient": {
          "publicKeyHex": "AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
          "balance": 51,
          "nonce": 1346.3838486778857
        },
        "token": {
          "tokenId": "d",
          "name": "granite",
          "contractAddress": "s",
          "ticker": "gran",
          "totalSupply": 1000000000,
          "circulatingSupply": 10
        },
        "value": 50,
        "gasfee": 1,
        "txHash": "3bc23591e99b33c526f1403aee081a2fb771ad7c4758d69ebe84d9808ebd65a2",
        "signature": {
          "r": "1291505327ca0bc8f1b17c2bc07b0b2559a3769b1301bed9111d5b4ff6b2dbd2",
          "s": "7563874100cd39272cc1a9ae4dc06b1be0ec23b8320a815f67dec5e6e732ea3b"
        },
        "txSecret": "7888dff662f1a04c52fd49bdb00abdea9a7ef62715675305b69ddd95450b93d0",
        "txSecretDiff": 4
      }
    ]
  }
}

---
./blockchain/blockchain.json
---
[]


---
./blockchain/unverified_blocks_pool.json
---


---
./blockchain/unverified_transactions_pool.json
---


---
./src/classes.ts
---
import type { AddressInterface, VerifiedTransaction } from "./interfaces";

export class AccountClass {
  private address: AddressClass;

  constructor(
    private readonly privateKeyHex: string,
    private readonly prefix: string,
    private readonly publicKeyHex: string,
    private balance: number,
    public readonly nonce: number,
    private readonly passKey: string
  ) {
    this.address = new AddressClass(this.publicKeyHex, this.balance, this.nonce);
  }

  // Delegateclass to Address 
  updateBalance(newBalance: number, passKey: string): void {
    if (!passKey || passKey !== this.passKey) {
      throw new Error("Incorrect Pass Key!");
    }
    this.address.updateBalance(newBalance);
    this.balance = newBalance; // Keep sync
  }

  get getAddress(): string {
    return `${this.prefix}_${this.publicKeyHex}`;
  }

  get getPublicKeyHex(): string {
    return this.publicKeyHex;
  }

  get currentBalance(): number {
    return this.balance;
  }

}

export class AddressClass {
  constructor(
    private readonly publicKeyHex: string,
    private balance: number,
    public readonly nonce: number,
  ) { }

  updateBalance(newBalance: number) {
    this.balance = newBalance;
    console.log("Balance Updated Successfully!");
  }

  get getPublicKeyHex(): string {
    return this.publicKeyHex;
  }
}

export class Block {
  public index: number;
  public hash: string;
  public previousHash: string;
  public timestamp: number;
  public difficulty: number;
  public nonce: number = Number(`${Date.now}-${Math.floor(Math.random() * 1000000)}`);
  public minterBalance: number;
  public minterAddress: AddressInterface;
  public accumulatorRoot: string;
  public transaction: VerifiedTransaction;

  constructor(index: number, hash: string, previousHash: string, timestamp: number, difficulty: number, minterBalance: number, minterAddress: AddressInterface, accumulatorRoot: string, transaction: VerifiedTransaction) {
    this.index = index;
    this.hash = hash;
    this.previousHash = previousHash;
    this.timestamp = timestamp;
    this.difficulty = difficulty;
    this.minterBalance = minterBalance;
    this.minterAddress = minterAddress;
    this.accumulatorRoot = accumulatorRoot;
    this.transaction = transaction;
  }
}




---
./src/constants.ts
---
import type { Token } from "./interfaces";
/// :::::::::::::::::: Paths :::::::::::::::::::::::

export const WALLET_PATH: string = "wallet/wallet_data.json";
export const BLOCKCHAIN_PATH: string = "blockchain/blockchain.json";
export const UNVERIFIED_BLOCKS_PATH: string = "blockchain/unverified_blocks_pool.json";
export const UNVERIFIED_TRANSACTIONS_PATH: string = "blockchain/unverified_transactions_pool.json";

/// :::::::::::::::::: Values ::::::::::::::::::::::
export const BASE62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

export const NATIVE_TOKEN: Token = {
  tokenId: 'd',
  name: 'granite',
  contractAddress: 's',
  ticker: 'gran',
  totalSupply: 1000000000, // 100 Million Native Tokens
  circulatingSupply: 10 // 10 Native Tokens in supply, the balance of the genesis sender and genesis receiver.
};




---
./src/data.ts
---
import { NATIVE_TOKEN } from './constants'
import type { AddressInterface, Transaction, TransactionData } from './interfaces'

export const genesisSender: AddressInterface = {
  publicKeyHex: 'AD_6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b',
  balance: 1,
  nonce: Math.random() * 10000
}

export const genesisReciever: AddressInterface = {
  publicKeyHex: 'AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35',
  balance: 1,
  nonce: Math.random() * 10000
}

export const genesisTx: Transaction<AddressInterface> = {
  sender: genesisSender,
  recipient: genesisReciever,
  token: NATIVE_TOKEN,
  value: 1,
  gasfee: 1,
  txHash: '',
  signature: { r: '', s: '' },
  txSecret: '8028f4ecd6da3344822baec652d52977973892f8766a6f78a8870f78c24ded51',
  txSecretDiff: 8,
  nonce: 120
}

export const mockTransactionData: TransactionData = [
  genesisTx,
  {
    sender: { publicKeyHex: 'AD_a1b2c3d4e5f6', balance: 100, nonce: 123 },
    recipient: { publicKeyHex: 'AD_f6e5d4c3b2a1', balance: 50, nonce: 456 },
    token: NATIVE_TOKEN,
    value: 25,
    gasfee: 1,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: '11aa22bb33cc44dd55ee66ff77gg88hh',
    txSecretDiff: 5,
    nonce: 344
  },
  {
    sender: { publicKeyHex: 'AD_abcdef123456', balance: 500, nonce: 789 },
    recipient: { publicKeyHex: 'AD_654321fedcba', balance: 300, nonce: 321 },
    token: NATIVE_TOKEN,
    value: 40,
    gasfee: 2,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: '99887766554433221100ffeeccbbddaa',
    txSecretDiff: 9,
    nonce: 123
  },
  {
    sender: { publicKeyHex: 'AD_111122223333', balance: 250, nonce: 987 },
    recipient: { publicKeyHex: 'AD_999988887777', balance: 150, nonce: 654 },
    token: NATIVE_TOKEN,
    value: 10,
    gasfee: 1,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: 'aabbccddeeff00112233445566778899',
    txSecretDiff: 3,
    nonce: 890
  },
  {
    sender: { publicKeyHex: 'AD_ff00ee11dd22', balance: 75, nonce: 222 },
    recipient: { publicKeyHex: 'AD_33cc44bb55aa', balance: 60, nonce: 333 },
    token: NATIVE_TOKEN,
    value: 5,
    gasfee: 1,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: '00112233445566778899aabbccddeeff',
    txSecretDiff: 7,
    nonce: 890
  }
]



---
./src/entry.ts
---
// main.ts (or your main server entry point)
import { serve } from '@hono/node-server';
import app from './server'; 

const port = 3000;
console.log(`Hono server running on http://localhost:${port}`);

serve({
  fetch: app.fetch, 
  port,
});

---
./src/interfaces.ts
---
import type { AccountClass, AddressClass } from './classes.ts'

export interface AddressInterface {
  readonly publicKeyHex: string;
  readonly balance: number;
  readonly nonce: number;
}

export interface WalletData {
  readonly accountDetails: AccountInterface<AddressInterface>;
  readonly transactionHistory: {
    TxIN: Transaction[];
    TxOut: Transaction[];
  }
}

export interface UnverifiedTransactionPoolInterface {
  pool: Transaction[];
}

export interface Block {
  readonly prevBlockHash: string;
  readonly currentBlockHash: string;
  readonly blockIndex: number;
  readonly blockHash: string;
  readonly transaction: VerifiedTransaction<AddressInterface>; /// Just one transaction per block to reduce complexity
  readonly timestamp: number;
  readonly validator: string;
  readonly accumulatorRoot: string;
  readonly difficulty: number;
}

export interface blockchainState {
  readonly chainLength: number;
  readonly chainSize: number;
  readonly nativeToken: Token;
  readonly cumulativeDifficulty: number;
}


export interface Blockchain {
  readonly blocks: Block[];
  readonly stateRoot: string;
  readonly state: blockchainState;
}


export interface AccountInterface<T = AddressClass | AddressInterface> {
  readonly privateKeyHex: string;
  readonly address: T;
}

export interface Transaction<Taddress = AddressClass | AddressInterface> {
  readonly nonce: number;
  readonly sender: Taddress;
  readonly recipient: Taddress;
  readonly token: Token;
  readonly value: number;
  readonly gasfee: number;
  readonly txHash: string;
  readonly signature: Signature;
  readonly txSecret: string;
  readonly txSecretDiff: number;
}

export interface VerifiedTransaction<Taddress = AddressClass | AddressInterface> {
  readonly nonce: number;
  readonly sender: Taddress;
  readonly recipient: Taddress;
  readonly token: Token;
  readonly value: number;
  readonly gasfee: number;
  readonly txHash: string;
  readonly signature: Signature;
  readonly txSecret: string;
  readonly txSecretDiff: number;
  readonly blockIndex: number;
}

export interface Token {
  readonly tokenId: string;
  readonly name: string;
  readonly contractAddress: string;
  readonly ticker: string;
  readonly totalSupply: number;
  readonly circulatingSupply: number;
}

export interface Signature {
  r: string;
  s: string;
}


---
./src/main.ts
---
// import CryptoJS from 'crypto-js';
import { createHash } from 'node:crypto';
import { genesisReciever, genesisSender, genesisTx, mockTransactionData } from './data.js';
import { diff } from 'node:util';
import * as Util from './util'
import BigNumber from 'bignumber.js';
import CryptoJS from 'crypto-js';
import { ec } from 'elliptic';
import type { Signature, Transaction, Token, AddressInterface, VerifiedTransaction } from './interfaces.ts'
import { AddressClass, AccountClass, Block } from './classes';
import { create } from 'node:domain';
import { getUnverifiedTransactionPool, selectRandomTransaction } from './transactionPool.js';
import { guessTxnSecret } from './wallet.js';

// CONSTANTS

const BLOCK_GENERATION_INTERVAL: number = 60; // Seconds

const DIFFICULTY_ADJUSTMENT_INTERVAL: number = 100 // Blocks

const NATIVE_TOKEN: Token = {
  tokenId: 'd',
  name: 'granite',
  contractAddress: 's',
  ticker: 'gran',
  totalSupply: 1000000000, // 100 Million Native Tokens
  circulatingSupply: 10 // 10 Native Tokens in supply, the balance of the genesis sender and genesis receiver.
};

// Initializing elliptic curve using secp256k 1
const ellipticCurve = new ec('secp256k1');

const genesisBlock: Block = new Block(0, 'aeebad4a796fcc2e15dc4c6061b45ed9b373f26adfc798ca7d2d8cc58182718e', 'null', 1465154705, 1, 1, genesisSender, 'accumulator', mockTransactionData[0]);

const calculateHash = (
  index: number,
  previousHash: string,
  timestamp: number,
  difficulty: number,
  minterAddress: AddressInterface,
  minterBalance: number,
  data: Transaction
): string => {
  const dataHash = data.txHash;
  return createHash('sha256')
    .update(index + previousHash + timestamp + dataHash + difficulty + minterBalance + minterAddress.publicKeyHex)
    .digest('hex');
};

const calculateHashForBlock = (block: Block): string => {
  const hash = calculateHash(block.index, block.previousHash, block.timestamp, block.difficulty, block.minterAddress, block.minterBalance, block.data[0]); /// -> For now the block hash is calculated only using the first transaction just to deal with any errors for now
  return hash;
}

// This function does nothing for now
function getLatestBlock(): Block {
  const randomTransaction: Transaction<AddressInterface> = {
    sender: {
      publicKeyHex: "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
      balance: 3.75,
      nonce: 4
    },
    recipient: {
      publicKeyHex: "3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy",
      balance: 12.89,
      nonce: 6
    },
    token: NATIVE_TOKEN,
    value: 0.15,
    gasfee: 0.0021,
    txHash: "0x4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6",
    signature: { r: '', s: '' },
    txSecret: "8028f4ecd6da3344822baec652d52977973892f8766a6f78a8870f78c24ded51",
    txSecretDiff: 8,
    nonce: 432
  }
  const randomBlock = new Block(5, '', '', 89, 1, 1, genesisSender, 'accumulator', mockTransactionData)
  return randomBlock;
}

const generateNextBlock = (blockData: Transaction): Block => {
  const previousBlock: Block = getLatestBlock();
  const nextIndex: number = previousBlock.index + 1;
  const nextTimestamp: number = new Date().getTime() / 1000;
  const nextHash: string = calculateHash(nextIndex, previousBlock.hash, nextTimestamp, 7, genesisSender, genesisSender.balance, blockData); /// Don't forget to change later, also modify the calculateHash function
  const newBlock: Block = new Block(nextIndex, nextHash, previousBlock.hash, nextTimestamp, 7, genesisSender.balance, genesisSender, "root", blockData);
  return newBlock;
}

// Block chain would be stored in an array for now
let blockchain: Block[] = [genesisBlock];

const isValidNewBlock = (newBlock: Block, previousBlock: Block): boolean => {

  if (previousBlock.index + 1 !== newBlock.index) {
    console.log('Invalid Index');
    return false;
  } else if (previousBlock.hash !== newBlock.previousHash) {
    console.log('invalid previoushash');
    return false;
  } else if (calculateHashForBlock(newBlock) !== newBlock.hash) {
    console.log(typeof (newBlock.hash) + '' + typeof calculateHashForBlock(newBlock));
    console.log('invalid hash; ' + calculateHashForBlock(newBlock) + '' + newBlock.hash);
    return false;
  }
  return true;
};


const isValidChain = (blockchainToValidate: Block[]): boolean => {
  const isValidGenesis = (block: Block | undefined): boolean => {
    if (!block) return false;
    return JSON.stringify(block) === JSON.stringify(genesisBlock);
  };

  if (!isValidGenesis(blockchainToValidate[0])) {
    return false;
  }

  for (let i = 1; i < blockchainToValidate.length; i++) {
    const currentBlock = blockchainToValidate[i];
    const prevBlock = blockchainToValidate[i - 1];

    if (!currentBlock || !prevBlock) return false;

    if (!isValidNewBlock(currentBlock, prevBlock)) {
      return false;
    }
  }

  return true;
};


// const replaceChain = (newBlocks: Block[]) => {
//     if (isValidChain(newBlocks) && newBlocks.length > getBlockchain().length) {
//         console.log('Recieved blockchain is valid. Replacing current blockchain with received blockchain');
//         blockchain = newBlocks;
//         broadcastLatest();
//     } else {
//         console.log('Received blockchain is invalid');
//     }
// }

const getCurrentTimestamp = (): number => {
  let latestBlock: Block = blockchain[blockchain.length - 1]!;
  return latestBlock.timestamp;
}

// const findBlock = (index: number, previousHash: string, data: Transaction | NFT, difficulty: number ): Block => {
//     let pastTimestamp: number = 0;
//     while (true) {
//         let timestamp: number = getCurrentTimestamp();
//         if(pastTimestamp !== timestamp) {
//             let hash: string = calculateHash(index, previousHash, timestamp, difficulty, getPublicFromWallet(), getAccountBalance(), data);
//             if (isBlockStakingValid(previousHash, getPublicFromWallet(), timestamp, getAccountBalance(), difficulty, index)) {
//                 return new Block(index, hash, previousHash, timestamp, difficulty, getAccountBalance(), getPublicFromWallet(), data);
//             }
//             pastTimestamp = timestamp; 
//         }
//     }
// };

const getDifficulty = (blockchain: Block[]): number => {
  if (!blockchain || blockchain.length === 0) {
    return -1; // or throw new Error("Blockchain is empty")
  }

  const latestBlock = blockchain[blockchain.length - 1]!; // always defined now

  if (latestBlock.index % DIFFICULTY_ADJUSTMENT_INTERVAL === 0 && latestBlock.index !== 0) {
    return getAdjustedDifficulty(latestBlock, blockchain);
  } else {
    return latestBlock.difficulty;
  }
};


const getAdjustedDifficulty = (latestBlock: Block, blockchain: Block[]): number => {
  const prevAdjustmentBlock: Block = blockchain[blockchain.length - DIFFICULTY_ADJUSTMENT_INTERVAL]!;
  const timeExpected: number = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;
  const timeTaken: number = latestBlock.timestamp - prevAdjustmentBlock.timestamp;
  if (timeTaken < timeExpected / 2) {
    return prevAdjustmentBlock.difficulty + 1;
  } else if (timeTaken > timeExpected * 2) {
    return prevAdjustmentBlock.difficulty - 1;
  } else {
    return prevAdjustmentBlock.difficulty
  }
};

const signTx = (txHash: string, privKeyHex: string): Signature => {
  const key = ellipticCurve.keyFromPrivate(privKeyHex, 'hex');
  const signature = key.sign(txHash, { canonical: true });

  return {
    r: signature.r.toString(16),
    s: signature.s.toString(16),
  };
};

const verifyTxSignature = (txHash: string, publicKeyHex: string, signature: { r: string, s: string }): boolean => {
  const key = ellipticCurve.keyFromPublic(publicKeyHex, 'hex');
  return key.verify(txHash, signature);
};

const verifyTxHash = (transaction: Transaction<AddressInterface>): boolean => {
  let storedTxHash: string = transaction.txHash;
  let calculatedTxHash: string = calculateHashForTransaction(transaction.sender, transaction.recipient, transaction.token, transaction.value, transaction.gasfee);
  return storedTxHash === calculatedTxHash;
}

const calculateHashForTransaction = (sender: AddressInterface, recipient: AddressInterface, token: Token, value: number, gasfee: number): string => {
  const result: string = createHash('sha256').update(sender.publicKeyHex + recipient.publicKeyHex + token.tokenId + value + gasfee).digest('hex');
  return result;
}

/// Verify Transaction
const verifyTx = (transaction: Transaction<AddressInterface>): boolean => {
  if (!verifyTxHash(transaction) || !verifyTxSignature(transaction.txHash, transaction.sender.publicKeyHex, transaction.signature)) {
    return false;
  };

  const userBalanceFromLocalDB = Util.getUserBalanceFromLocalBC(transaction.sender.publicKeyHex);
  if (userBalanceFromLocalDB < (transaction.value + transaction.gasfee)) return false;

  return true
}

/// Mint a block
const mintBlock = async (): Promise<Block> => {
  const pool = getUnverifiedTransactionPool();
  const transaction = selectRandomTransaction(1, pool) as Transaction<AddressInterface>;

  if (!verifyTx(transaction)) throw new Error("Invalid Transaction selected from pool");

  const guessedTxnSecret = await guessTxnSecret(transaction.txSecretDiff, transaction.txSecret);

  const prevBlock = getLatestBlock();
  const nextIndex = prevBlock.index + 1;
  const timestamp = Date.now() / 1000;

  const verifiedTransaction: VerifiedTransaction = {
    ...transaction,
    blockIndex: nextIndex
  };

  const minerAddress = genesisSender; /// Should be the current node address not miner, I'll add the update later
  const minerBalance = Util.getUserBalanceFromLocalBC(minerAddress.publicKeyHex);

  const hash = calculateHash(
    nextIndex,
    prevBlock.hash,
    timestamp,
    7, /// Difficulty (hardcoded for now, it should be the same value as transaction difficulty)
    minerAddress,
    minerBalance,
    verifiedTransaction
  );

  const newBlock = new Block(
    nextIndex,
    hash,
    prevBlock.hash,
    timestamp,
    7,
    minerBalance,
    minerAddress,
    "accumulator-placeholder", /// I'll have to change this since I won't be using the accumulator for this mvp
    verifiedTransaction
  );

  return newBlock;
}


---
./src/polynomial_accumulator.ts
---
interface Proof {
    coef_1: bigint;
    coef_2: bigint;
    coef_3: bigint;
    coef_4: bigint;
    coef_5: bigint;
}

type Params = [bigint, bigint, bigint, bigint, bigint];

export function createProof(arg: Params): Proof {
    const argSet = new Set(arg);
    if (argSet.size !== arg.length) throw new Error("All params must be unique!");
    const [a, b, c, d, e] = arg;
    if (a.toString().length !== 5 || b.toString().length !== 5 || c.toString().length !== 5 || d.toString().length !== 5 || e.toString().length !== 5 ) {
        throw new Error("All parameters must be 5 numbers long!");
    }
    
    const proof: Proof = {
        coef_1: a + b + c + d + e,
        coef_2: a*b + a*c + a*d + a*e + b*c + b*d + b*e + c*d + c*e + d*e,
        coef_3: a*b*c + a*b*d + a*b*e + a*c*d + a*c*e + a*d*e + b*c*d + b*c*e + b*d*e + c*d*e,
        coef_4: a*b*c*d + a*b*c*e + a*b*d*e + a*c*d*e + b*c*d*e,
        coef_5: a*b*c*d*e
    };
    console.log("This is the length of the first string: ", a.toString().length)
    return proof;
}

export function verifyRoot(proof: Proof, originalParam: bigint): boolean {
    const root = -originalParam;
    const result = 
        (root ** 5n) + 
        (proof.coef_1 * (root ** 4n)) + 
        (proof.coef_2 * (root ** 3n)) + 
        (proof.coef_3 * (root ** 2n)) + 
        (proof.coef_4 * root) + 
        proof.coef_5;
    return result === 0n; 
}

const myParams: Params = [12375n, 27987n, 37438n, 47487n, 57986n];

const myProof = createProof(myParams);
console.log("Proof (Coefficients):", myProof);

console.log("--- Verifying Correct Roots ---");
console.log("Verifying root for param 1235n:", verifyRoot(myProof, 12375n));
console.log("Verifying root for param 2987n:", verifyRoot(myProof, 27987n));
console.log("Verifying root for param 3438n:", verifyRoot(myProof, 37438n));
console.log("Verifying root for param 4487n:", verifyRoot(myProof, 47487n));
console.log("Verifying root for param 5986n:", verifyRoot(myProof, 57986n));

console.log("--- Verifying Incorrect Root ---");
console.log("Verifying non-root (testing -7n):", verifyRoot(myProof, 7n));

---
./src/server.ts
---
import { Hono } from 'hono';

const app = new Hono();

/// :::::::::::::: Blockchain Network Endpoints :::::::::::::::::

/// get blockchain
app.get('/blocks', async (c) => {
    
});

/// get user transaction history 
app.get('/transactions', async (c) => {
    
});

/// mint a block
app.post('/mintBlock', async (c) => {

});

/// mint a transaction
app.post('/mintTransaction', async (c) => {

})

export default app;

// const initHttpServer = ( myHttpPort: number ) => {
//     const app = express();
//     app.use(bodyParser.json());

//     app.get('/blocks', (req, res) => {
//         res.send(getBlockchain());
//     });
//     app.post('/mintBlock', (req, res) => {
//         const newBlock: Block = generateNextBlock(req.body.data);
//         res.send(newBlock);
//     });
//     app.get('/peers', (req, res) => {
//         res.send(getSockets().map(( s: any ) => s._socket.remoteAddress + ':' + s._socket.remotePort));
//     });
//     app.post('/addPeer', (req, res) => {
//         connectToPeers(req.body.peer);
//         res.send();
//     });

//     app.listen(myHttpPort, () => {
//         console.log('Listening http on port: ' + myHttpPort);
//     });
// };

---
./src/transactionPool.ts
---
import type * as Interfaces from "./interfaces.ts"
import { readFile } from "./util"
import { UNVERIFIED_TRANSACTIONS_PATH } from "./constants.js";

export function getUnverifiedTransactionPool(): Interfaces.Transaction<Interfaces.AddressInterface>[] {
  const data = readFile(UNVERIFIED_TRANSACTIONS_PATH) as Interfaces.UnverifiedTransactionPoolInterface;
  if (!data) throw new Error("An error occured");
  return data.pool as Interfaces.Transaction<Interfaces.AddressInterface>[];
};

export function selectRandomTransaction(n: number = 1, transactionData: Interfaces.Transaction<Interfaces.AddressInterface>[]): Interfaces.Transaction<Interfaces.AddressInterface> { /// -> This function should only select just one transaction by default
  if (transactionData.length === 0) throw new Error("There's nothing in the transaction data");
  if (n < 1) throw new Error("Pick a valid number!");
  const randomIndex = Math.floor(Math.random() * transactionData.length);
  const result: Interfaces.Transaction<Interfaces.AddressInterface> = transactionData[randomIndex] as Interfaces.Transaction<Interfaces.AddressInterface>;
  return result
}


---
./src/util.ts
---
import { readFileSync, writeFileSync, existsSync, statSync } from 'fs';
import * as Interfaces from './interfaces';
import { createHash, randomBytes } from 'node:crypto';
import { ec } from 'elliptic'
import * as CONSTANTS from './constants'
import { Block } from './interfaces';

const ellipticCurve = new ec('secp256k1');

/// Read data from a file
export function readFile(filePath: string): Interfaces.WalletData | Interfaces.UnverifiedTransactionPoolInterface | Interfaces.Block[] {
  let data: string;
  try {
    data = readFileSync(filePath, 'utf-8');
  } catch (error) {
    console.error("Error reading file: ", error);
    throw error;
  }
  return JSON.parse(data)
}

/// Sign transactions

export const signTx = (txHash: string, privKeyHex: string): Interfaces.Signature => {
  const key = ellipticCurve.keyFromPrivate(privKeyHex, 'hex');
  const signature = key.sign(txHash, { canonical: true });

  return {
    r: signature.r.toString(16),
    s: signature.s.toString(16),
  };
};

const calculateHashForTransaction = (sender: Interfaces.AddressInterface, recipient: Interfaces.AddressInterface, token: Interfaces.Token, value: number, gasfee: number): string => {
  const result: string = createHash('sha256').update(sender.publicKeyHex + sender.balance + recipient.publicKeyHex + recipient.balance + token.tokenId + value + gasfee).digest('hex');
  return result;
}

const verifyTxHash = (transaction: Interfaces.Transaction<Interfaces.AddressInterface>): boolean => {
  let storedTxHash: string = transaction.txHash;
  let calculatedTxHash: string = calculateHashForTransaction(transaction.sender, transaction.recipient, transaction.token, transaction.value, transaction.gasfee);
  return storedTxHash === calculatedTxHash;
}

/// Write to a file
function writeFile(filePath: string, data: object): void {
  const sData = JSON.stringify(data, null, 2);
  try {
    writeFileSync(filePath, sData, 'utf-8');
  } catch (error) {
    console.error("Error writing file: ", error);
    throw error
  }
}


/// Check if a file exists
function checkIfFileExists(filePath: string): boolean {
  try {
    return existsSync(filePath) && statSync(filePath).isFile();
  } catch (error) {
    return false
  }
}

/// Check if file is empty
function checkIfFileIsEmpty(filePath: string): boolean {
  if (checkIfFileExists(filePath)) {
    const fileData = readFile(filePath);
    if (Object.keys(fileData).length === 0) {
      return true;
    }
  }
  return false
}

/// Generate key pair
const genKeyPair = (): { privKey: string, pubKey: string } => {
  const keyPair = ellipticCurve.genKeyPair();
  const privateKey = keyPair.getPrivate('hex');
  const publicKey = keyPair.getPublic('hex');

  return {
    privKey: privateKey,
    pubKey: publicKey
  }
}

function genUniqueNonce(): number {
  const timestamp = Date.now();
  const timestampPart = timestamp % 1000000;
  const randomNumber = randomBytes(2).readUInt16BE(0);

  return timestampPart + randomNumber;
}

export const getUserBalanceFromLocalBC = (senderPublicKeyHex: string): number => {
  if (!checkIfFileExists(CONSTANTS.BLOCKCHAIN_PATH)) throw new Error("Block chain file doesn't exist");
  const blockchain: Block[] = readFile(CONSTANTS.BLOCKCHAIN_PATH) as Block[];
  if (blockchain.length === 0) throw new Error("The blockchain is empty")
  let balance = 0;
  blockchain.forEach(block => {
    const tx = block.transaction;

    if (tx.recipient.publicKeyHex === senderPublicKeyHex) {
      balance += tx.value;
    }

    if (tx.sender.publicKeyHex === senderPublicKeyHex) {
      balance -= (tx.value + tx.gasfee);
    }
  });
  return balance;
}


---
./src/wallet.ts
---
import CryptoJS from 'crypto-js';
import { createHash, randomBytes } from 'node:crypto';
import crypto from 'crypto';
import { ec } from 'elliptic';
import type { AccountInterface, AddressInterface, Transaction, Token, Signature, WalletData } from './interfaces.ts';
import { AccountClass, AddressClass } from './classes.js';
import { readFileSync, writeFileSync, existsSync, statSync } from 'fs';
import * as path from 'path';
import { read } from 'node:fs';
import baseX from 'base-x'
import { WALLET_PATH, BLOCKCHAIN_PATH, BASE62 } from './constants.js'
const ellipticCurve = new ec('secp256k1');

/// CONSTANTS 

const DEFAULT_BALANCE: number = 0;
const MAX_DIFFICULTY: 16 = 16;
const MIN_DIFFICULTY: 4 = 4;
const CURRENT_DIFFICULTY: number = 4
const GAS_FEE: number = 1;
const NATIVE_TOKEN: Token = {
  tokenId: 'd',
  name: 'granite',
  contractAddress: 's',
  ticker: 'gran',
  totalSupply: 1000000000, // 100 Million Native Tokens
  circulatingSupply: 10 // 10 Native Tokens in supply, the balance of the genesis sender and genesis receiver.
};
const testReciever: AddressInterface = {
  publicKeyHex: 'AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35',
  balance: 1,
  nonce: Math.random() * 10000 // Don't forget to change later
};

/// Read data from a file
export function readFile(filePath: string): WalletData {
  let data: string;
  try {
    data = readFileSync(filePath, 'utf-8');
  } catch (error) {
    console.error("Error reading file: ", error);
    throw error;
  }
  return JSON.parse(data)
}

/// Sign transactions

const signTx = (txHash: string, privKeyHex: string): Signature => {
  const key = ellipticCurve.keyFromPrivate(privKeyHex, 'hex');
  const signature = key.sign(txHash, { canonical: true });

  return {
    r: signature.r.toString(16),
    s: signature.s.toString(16),
  };
};

const calculateHashForTransaction = (sender: AddressInterface, recipient: AddressInterface, token: Token, value: number, gasfee: number): string => {
  const result: string = createHash('sha256').update(sender.publicKeyHex + sender.balance + recipient.publicKeyHex + recipient.balance + token.tokenId + value + gasfee).digest('hex');
  return result;
}

const verifyTxHash = (transaction: Transaction<AddressInterface>): boolean => {
  let storedTxHash: string = transaction.txHash;
  let calculatedTxHash: string = calculateHashForTransaction(transaction.sender, transaction.recipient, transaction.token, transaction.value, transaction.gasfee);
  return storedTxHash === calculatedTxHash;
}

/// Write to a file
function writeFile(filePath: string, data: object): void {
  const sData = JSON.stringify(data, null, 2);
  try {
    writeFileSync(filePath, sData, 'utf-8');
  } catch (error) {
    console.error("Error writing file: ", error);
    throw error
  }
}


/// Check if a file exists
function checkIfFileExists(filePath: string): boolean {
  try {
    return existsSync(filePath) && statSync(filePath).isFile();
  } catch (error) {
    return false
  }
}

/// Check if file is empty
function checkIfFileIsEmpty(filePath: string): boolean {
  if (checkIfFileExists(filePath)) {
    const fileData = readFile(filePath);
    if (Object.keys(fileData).length === 0) {
      return true;
    }
  }
  return false
}

/// Generate key pair
const genKeyPair = (): { privKey: string, pubKey: string } => {
  const keyPair = ellipticCurve.genKeyPair();
  const privateKey = keyPair.getPrivate('hex');
  const publicKey = keyPair.getPublic('hex');

  return {
    privKey: privateKey,
    pubKey: publicKey
  }
}

function genUniqueNonce(): number {
  const timestamp = Date.now();
  const timestampPart = timestamp % 1000000;
  const randomNumber = randomBytes(2).readUInt16BE(0);

  return timestampPart + randomNumber;
}

function genWallet(): WalletData {
  const hexKeyPair = genKeyPair();
  const wallet_data: WalletData = {
    accountDetails: {
      privateKeyHex: hexKeyPair.privKey,
      address: {
        publicKeyHex: hexKeyPair.pubKey,
        balance: DEFAULT_BALANCE,
        nonce: genUniqueNonce()
      }
    },
    transactionHistory: {
      TxIN: [],
      TxOut: []
    }
  }

  return wallet_data;
}

function createWallet() {
  const fileExists: boolean = checkIfFileExists(WALLET_PATH);
  const fileIsEmpty: boolean = checkIfFileIsEmpty(WALLET_PATH);
  if (!fileExists || fileIsEmpty) {
    writeFile(WALLET_PATH, genWallet());
    console.log("Wallet created successfully")
    return;
  }
  console.error("Wallet could not be created because it already exists!")
  return;
}

function makeTransaction(recipientAddr: AddressInterface, amountToSend: number,): Transaction<AddressInterface> {
  const wallet_data = readFile(WALLET_PATH);
  if (wallet_data.accountDetails.address.balance < amountToSend) {
    throw new Error(`You don't have enough ${NATIVE_TOKEN.name} to make this transaction`)
  }
  const newSenderBalance = wallet_data.accountDetails.address.balance - amountToSend - GAS_FEE;
  const newReceiverBalance = recipientAddr.balance + amountToSend;
  const transactionHash = calculateHashForTransaction(wallet_data.accountDetails.address, recipientAddr, NATIVE_TOKEN, amountToSend, GAS_FEE);
  const transactionSignature = signTx(transactionHash, wallet_data.accountDetails.privateKeyHex);
  const transaction: Transaction<AddressInterface> = {
    sender: {
      publicKeyHex: wallet_data.accountDetails.address.publicKeyHex,
      nonce: wallet_data.accountDetails.address.nonce,
      balance: newSenderBalance
    },
    recipient: {
      publicKeyHex: recipientAddr.publicKeyHex,
      balance: newReceiverBalance,
      nonce: recipientAddr.nonce
    },
    token: NATIVE_TOKEN,
    value: amountToSend,
    gasfee: GAS_FEE,
    txHash: transactionHash,
    signature: transactionSignature,
    txSecret: generateTxnSecret(CURRENT_DIFFICULTY),
    txSecretDiff: CURRENT_DIFFICULTY,
    nonce: 789
  }

  const wallet_data_class = new AddressClass(wallet_data.accountDetails.address.publicKeyHex, wallet_data.accountDetails.address.balance, wallet_data.accountDetails.address.nonce);
  wallet_data_class.updateBalance(newSenderBalance);
  const updated_wallet_data: WalletData = {
    accountDetails: {
      privateKeyHex: wallet_data.accountDetails.privateKeyHex,
      address: {
        publicKeyHex: wallet_data.accountDetails.address.publicKeyHex,
        balance: newSenderBalance,
        nonce: wallet_data.accountDetails.address.nonce
      }
    },
    transactionHistory: {
      TxIN: [...wallet_data.transactionHistory.TxIN],
      TxOut: [...wallet_data.transactionHistory.TxOut, transaction]
    }
  }

  writeFile(WALLET_PATH, updated_wallet_data)

  console.log("This is the transaction data: ", transaction);
  console.log("This is the updated wallet data: ", updated_wallet_data)
  return transaction;
}

const verifyTxSignature = (txHash: string, publicKeyHex: string, signature: { r: string, s: string }): boolean => {
  const key = ellipticCurve.keyFromPublic(publicKeyHex, 'hex');
  return key.verify(txHash, signature);
};

const verifyBalanceFromTransactionHistory = (): boolean => {
  console.log("Checking Transaction History");

  const wallet_data = readFile(WALLET_PATH);
  const wallet_balance = wallet_data.accountDetails.address.balance;

  // Verify transaction hashes
  const unverifiedTransactionsOut = (wallet_data.transactionHistory.TxOut as Transaction<AddressInterface>[]).map(_ => verifyTxHash(_)).filter(_ => _ === false);
  const unverifiedTransactionsIn = (wallet_data.transactionHistory.TxIN as Transaction<AddressInterface>[]).map(_ => verifyTxHash(_)).filter(_ => _ === false);

  if (unverifiedTransactionsIn.length > 0 || unverifiedTransactionsOut.length > 0) {
    console.error("Error: You have transactions with unverified transaction hashes and as such your entire transaction history is likely false");
    return false;
  }

  // Verify transaciton signatures
  const unverifiedTransactionsSigOut = (wallet_data.transactionHistory.TxOut as Transaction<AddressInterface>[]).map(_ => verifyTxSignature(_.txHash, _.sender.publicKeyHex, _.signature)).filter(_ => _ === false);
  const unverifiedTransactionsSigIn = (wallet_data.transactionHistory.TxIN as Transaction<AddressInterface>[]).map(_ => verifyTxSignature(_.txHash, _.sender.publicKeyHex, _.signature)).filter(_ => _ === false);

  if (unverifiedTransactionsSigIn.length > 0 || unverifiedTransactionsSigOut.length > 0) {
    console.error("Error: You have transactions with unverified transaction hashes and as such your entire transaction history is likely false");
    return false;
  }

  if (wallet_balance == 0 && wallet_data.transactionHistory.TxIN.length === 0) {
    console.error(`Error: Your wallet balance of: ${wallet_balance} ${NATIVE_TOKEN.name} doesn't correspond with your transaction history.`)
    return false;
  }

  const totalTransactionsOut = wallet_data.transactionHistory.TxOut.map(_ => _.value).reduce((sum, curr) => sum + curr, 0) + (wallet_data.transactionHistory.TxOut.length * GAS_FEE);
  const totalTransactionsIn = wallet_data.transactionHistory.TxOut.map(_ => _.value).reduce((sum, curr) => sum + curr, 0);


  if (wallet_balance !== totalTransactionsIn - totalTransactionsOut) {
    console.error(`Error: Your wallet balance of: ${wallet_balance} ${NATIVE_TOKEN} doesn't correspond with your transaction history.`)
    return false
  }

  return true;
}

const getAccountBalance = (): number | undefined => {
  const wallet_data = readFile(WALLET_PATH);
  const walletVerified = verifyBalanceFromTransactionHistory();
  if (!walletVerified) {
    console.error("Your account balance could not be verified")
    return
  }
  return wallet_data.accountDetails.address.balance
}

/// Create a secret for a transaction
export const generateTxnSecret = (difficulty: number): string => {
  const base52 = baseX(BASE62);
  if (difficulty > MAX_DIFFICULTY || difficulty < MIN_DIFFICULTY) throw new Error("Invalid difficulty");
  const trailingZeros: string = '0'.repeat((MAX_DIFFICULTY + 1) - difficulty);
  const str: string = base52.encode(randomBytes(13));
  const truncated: string = str.slice(0, difficulty);
  const secret: string = trailingZeros + truncated;
  const result: string = createHash('sha256').update(secret).digest('hex');
  console.log("Secret: ", secret);
  console.log(result);
  return result
}

/// Guess transaction secret
export const guessTxnSecret = async (difficulty: number, secretHash: string): Promise<string> => {
  if (difficulty > MAX_DIFFICULTY || difficulty < MIN_DIFFICULTY)
    throw new Error("Invalid difficulty");
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const trailingZeros = "0".repeat((MAX_DIFFICULTY + 1) - difficulty);

  while (true) {
    let s = "";
    for (let i = 0; i < difficulty; i++) {
      s += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    const secret = trailingZeros + s;
    console.log("guess: ", secret)
    const guess = createHash("sha256").update(secret).digest("hex");
    if (guess === secretHash) {
      console.log("Correct guess:", secret);
      return secret;
    }
  }
};

/// Verify transaction secret guess
const verifyTxSecret = (secretHash: string, guess: string): boolean => {
  const guessHash = createHash('sha256').update(guess).digest('hex');
  return guessHash === secretHash;
}


// verifyBalanceFromTransactionHistory();
// makeTransaction(testReciever, 50);
console.log("Is user balance correct?: ", verifyBalanceFromTransactionHistory());
// generateTxnSecret(4);
// guessTxnSecret(4,"935aee836cfee766db9a51db08046d3f721f2553a593ff92dd2466f7e682626a") /// secret to find -> 000000000000052Dq


---


---
./package-lock.json
---
{
  "name": "granite-blockchain-mvp",
  "version": "0.0.1",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "granite-blockchain-mvp",
      "version": "0.0.1",
      "license": "ISC",
      "dependencies": {
        "@hono/node-server": "^1.19.5",
        "@types/elliptic": "^6.4.18",
        "base-x": "^5.0.1",
        "better-sqlite3": "^12.4.1",
        "bignumber.js": "^9.3.1",
        "crypto-js": "^4.2.0",
        "elliptic": "^6.6.1",
        "hono": "^4.10.2",
        "openpgp": "^6.2.2"
      },
      "devDependencies": {
        "@types/better-sqlite3": "^7.6.13",
        "@types/crypto-js": "^4.2.2",
        "@types/node": "^24.5.2"
      }
    },
    "node_modules/@hono/node-server": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@hono/node-server/-/node-server-1.19.5.tgz",
      "integrity": "sha512-iBuhh+uaaggeAuf+TftcjZyWh2GEgZcVGXkNtskLVoWaXhnJtC5HLHrU8W1KHDoucqO1MswwglmkWLFyiDn4WQ==",
      "engines": {
        "node": ">=18.14.1"
      },
      "peerDependencies": {
        "hono": "^4"
      }
    },
    "node_modules/@types/better-sqlite3": {
      "version": "7.6.13",
      "resolved": "https://registry.npmmirror.com/@types/better-sqlite3/-/better-sqlite3-7.6.13.tgz",
      "integrity": "sha512-NMv9ASNARoKksWtsq/SHakpYAYnhBrQgGD8zkLYk/jaK8jUGn08CfEdTRgYhMypUQAfzSP8W6gNLe0q19/t4VA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmmirror.com/@types/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-DLbJ1BPqxvQhIGbeu8VbUC1DiAiahHtAYvA0ZEAa4P31F7IaArc8z3C3BRQdWX4mtLQuABG4yzp76ZrS02Ui1Q==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/crypto-js": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/@types/crypto-js/-/crypto-js-4.2.2.tgz",
      "integrity": "sha512-sDOLlVbHhXpAUAL0YHDUUwDZf3iN4Bwi4W6a0W0b+QcAezUbRtH4FVb+9J4h+XFPW7l/gQ9F8qC7P+Ec4k8QVQ==",
      "dev": true
    },
    "node_modules/@types/elliptic": {
      "version": "6.4.18",
      "resolved": "https://registry.npmmirror.com/@types/elliptic/-/elliptic-6.4.18.tgz",
      "integrity": "sha512-UseG6H5vjRiNpQvrhy4VF/JXdA3V/Fp5amvveaL+fs28BZ6xIKJBPnUPRlEaZpysD9MbpfaLi8lbl7PGUAkpWw==",
      "license": "MIT",
      "dependencies": {
        "@types/bn.js": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "24.5.2",
      "resolved": "https://registry.npmmirror.com/@types/node/-/node-24.5.2.tgz",
      "integrity": "sha512-FYxk1I7wPv3K2XBaoyH2cTnocQEu8AOZ60hPbsyukMPLv5/5qr7V1i8PLHdl6Zf87I+xZXFvPCXYjiTFq+YSDQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.12.0"
      }
    },
    "node_modules/base-x": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-5.0.1.tgz",
      "integrity": "sha512-M7uio8Zt++eg3jPj+rHMfCC+IuygQHHCOU+IYsVtik6FWjuYpVt/+MRKcgsAMHh8mMFAwnB+Bs+mTrFiXjMzKg==",
      "license": "MIT"
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmmirror.com/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/better-sqlite3": {
      "version": "12.4.1",
      "resolved": "https://registry.npmmirror.com/better-sqlite3/-/better-sqlite3-12.4.1.tgz",
      "integrity": "sha512-3yVdyZhklTiNrtg+4WqHpJpFDd+WHTg2oM7UcR80GqL05AOV0xEJzc6qNvFYoEtE+hRp1n9MpN6/+4yhlGkDXQ==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "bindings": "^1.5.0",
        "prebuild-install": "^7.1.1"
      },
      "engines": {
        "node": "20.x || 22.x || 23.x || 24.x"
      }
    },
    "node_modules/bignumber.js": {
      "version": "9.3.1",
      "resolved": "https://registry.npmmirror.com/bignumber.js/-/bignumber.js-9.3.1.tgz",
      "integrity": "sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==",
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmmirror.com/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "license": "MIT",
      "dependencies": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "node_modules/bl": {
      "version": "4.1.0",
      "resolved": "https://registry.npmmirror.com/bl/-/bl-4.1.0.tgz",
      "integrity": "sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==",
      "license": "MIT",
      "dependencies": {
        "buffer": "^5.5.0",
        "inherits": "^2.0.4",
        "readable-stream": "^3.4.0"
      }
    },
    "node_modules/bn.js": {
      "version": "4.12.2",
      "resolved": "https://registry.npmmirror.com/bn.js/-/bn.js-4.12.2.tgz",
      "integrity": "sha512-n4DSx829VRTRByMRGdjQ9iqsN0Bh4OolPsFnaZBLcbi8iXcB+kJ9s7EnRt4wILZNV3kPLHkRVfOc/HvhC3ovDw==",
      "license": "MIT"
    },
    "node_modules/brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmmirror.com/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha512-cKV8tMCEpQs4hK/ik71d6LrPOnpkpGBR0wzxqr68g2m/LB2GxVYQroAjMJZRVM1Y4BCjCKc3vAamxSzOY2RP+w==",
      "license": "MIT"
    },
    "node_modules/buffer": {
      "version": "5.7.1",
      "resolved": "https://registry.npmmirror.com/buffer/-/buffer-5.7.1.tgz",
      "integrity": "sha512-EHcyIPBQ4BSGlvjB16k5KgAJ27CIsHY/2JBmCRReo48y9rQ3MaUzWX3KVlBa4U7MyX02HdVj0K7C3WaB3ju7FQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "base64-js": "^1.3.1",
        "ieee754": "^1.1.13"
      }
    },
    "node_modules/chownr": {
      "version": "1.1.4",
      "resolved": "https://registry.npmmirror.com/chownr/-/chownr-1.1.4.tgz",
      "integrity": "sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==",
      "license": "ISC"
    },
    "node_modules/crypto-js": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/crypto-js/-/crypto-js-4.2.0.tgz",
      "integrity": "sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q=="
    },
    "node_modules/decompress-response": {
      "version": "6.0.0",
      "resolved": "https://registry.npmmirror.com/decompress-response/-/decompress-response-6.0.0.tgz",
      "integrity": "sha512-aW35yZM6Bb/4oJlZncMH2LCoZtJXTRxES17vE3hoRiowU2kWHaJKFkSBDnDR+cm9J+9QhXmREyIfv0pji9ejCQ==",
      "license": "MIT",
      "dependencies": {
        "mimic-response": "^3.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/deep-extend": {
      "version": "0.6.0",
      "resolved": "https://registry.npmmirror.com/deep-extend/-/deep-extend-0.6.0.tgz",
      "integrity": "sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA==",
      "license": "MIT",
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.1.1",
      "resolved": "https://registry.npmmirror.com/detect-libc/-/detect-libc-2.1.1.tgz",
      "integrity": "sha512-ecqj/sy1jcK1uWrwpR67UhYrIFQ+5WlGxth34WquCbamhFA6hkkwiu37o6J5xCHdo1oixJRfVRw+ywV+Hq/0Aw==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/elliptic": {
      "version": "6.6.1",
      "resolved": "https://registry.npmmirror.com/elliptic/-/elliptic-6.6.1.tgz",
      "integrity": "sha512-RaddvvMatK2LJHqFJ+YA4WysVN5Ita9E35botqIYspQ4TkRAlCicdzKOjlyv/1Za5RyTNn7di//eEV0uTAfe3g==",
      "license": "MIT",
      "dependencies": {
        "bn.js": "^4.11.9",
        "brorand": "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        "inherits": "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/end-of-stream": {
      "version": "1.4.5",
      "resolved": "https://registry.npmmirror.com/end-of-stream/-/end-of-stream-1.4.5.tgz",
      "integrity": "sha512-ooEGc6HP26xXq/N+GCGOT0JKCLDGrq2bQUZrQ7gyrJiZANJ/8YDTxTpQBXGMn+WbIQXNVpyWymm7KYVICQnyOg==",
      "license": "MIT",
      "dependencies": {
        "once": "^1.4.0"
      }
    },
    "node_modules/expand-template": {
      "version": "2.0.3",
      "resolved": "https://registry.npmmirror.com/expand-template/-/expand-template-2.0.3.tgz",
      "integrity": "sha512-XYfuKMvj4O35f/pOXLObndIRvyQ+/+6AhODh+OKWj9S9498pHHn/IMszH+gt0fBCRWMNfk1ZSp5x3AifmnI2vg==",
      "license": "(MIT OR WTFPL)",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==",
      "license": "MIT"
    },
    "node_modules/fs-constants": {
      "version": "1.0.0",
      "resolved": "https://registry.npmmirror.com/fs-constants/-/fs-constants-1.0.0.tgz",
      "integrity": "sha512-y6OAwoSIf7FyjMIv94u+b5rdheZEjzR63GTyZJm5qh4Bi+2YgwLCcI/fPFZkL5PSixOt6ZNKm+w+Hfp/Bciwow==",
      "license": "MIT"
    },
    "node_modules/github-from-package": {
      "version": "0.0.0",
      "resolved": "https://registry.npmmirror.com/github-from-package/-/github-from-package-0.0.0.tgz",
      "integrity": "sha512-SyHy3T1v2NUXn29OsWdxmK6RwHD+vkj3v8en8AOBZ1wBQ/hCAQ5bAQTD02kW4W9tUp/3Qh6J8r9EvntiyCmOOw==",
      "license": "MIT"
    },
    "node_modules/hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmmirror.com/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "node_modules/hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha512-Tti3gMqLdZfhOQY1Mzf/AanLiqh1WTiJgEj26ZuYQ9fbkLomzGchCws4FyrSd4VkpBfiNhaE1On+lOz894jvXg==",
      "license": "MIT",
      "dependencies": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "node_modules/hono": {
      "version": "4.10.4",
      "resolved": "https://registry.npmjs.org/hono/-/hono-4.10.4.tgz",
      "integrity": "sha512-YG/fo7zlU3KwrBL5vDpWKisLYiM+nVstBQqfr7gCPbSYURnNEP9BDxEMz8KfsDR9JX0lJWDRNc6nXX31v7ZEyg==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=16.9.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmmirror.com/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmmirror.com/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ini": {
      "version": "1.3.8",
      "resolved": "https://registry.npmmirror.com/ini/-/ini-1.3.8.tgz",
      "integrity": "sha512-JV/yugV2uzW5iMRSiZAyDtQd+nxtUnjeLt0acNdw98kKLrvuRVyB80tsREOE7yvGVgalhZ6RNXCmEHkUKBKxew==",
      "license": "ISC"
    },
    "node_modules/mimic-response": {
      "version": "3.1.0",
      "resolved": "https://registry.npmmirror.com/mimic-response/-/mimic-response-3.1.0.tgz",
      "integrity": "sha512-z0yWI+4FDrrweS8Zmt4Ej5HdJmky15+L2e6Wgn3+iK5fWzb6T3fhNFq2+MeTRb064c6Wr4N/wv0DzQTjNzHNGQ==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A==",
      "license": "ISC"
    },
    "node_modules/minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha512-JIYlbt6g8i5jKfJ3xz7rF0LXmv2TkDxBLUkiBeZ7bAx4GnnNMr8xFpGnOxn6GhTEHx3SjRrZEoU+j04prX1ktg==",
      "license": "MIT"
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmmirror.com/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/mkdirp-classic": {
      "version": "0.5.3",
      "resolved": "https://registry.npmmirror.com/mkdirp-classic/-/mkdirp-classic-0.5.3.tgz",
      "integrity": "sha512-gKLcREMhtuZRwRAfqP3RFW+TK4JqApVBtOIftVgjuABpAtpxhPGaDcfvbhNvD0B8iD1oUr/txX35NjcaY6Ns/A==",
      "license": "MIT"
    },
    "node_modules/napi-build-utils": {
      "version": "2.0.0",
      "resolved": "https://registry.npmmirror.com/napi-build-utils/-/napi-build-utils-2.0.0.tgz",
      "integrity": "sha512-GEbrYkbfF7MoNaoh2iGG84Mnf/WZfB0GdGEsM8wz7Expx/LlWf5U8t9nvJKXSp3qr5IsEbK04cBGhol/KwOsWA==",
      "license": "MIT"
    },
    "node_modules/node-abi": {
      "version": "3.77.0",
      "resolved": "https://registry.npmmirror.com/node-abi/-/node-abi-3.77.0.tgz",
      "integrity": "sha512-DSmt0OEcLoK4i3NuscSbGjOf3bqiDEutejqENSplMSFA/gmB8mkED9G4pKWnPl7MDU4rSHebKPHeitpDfyH0cQ==",
      "license": "MIT",
      "dependencies": {
        "semver": "^7.3.5"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmmirror.com/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/openpgp": {
      "version": "6.2.2",
      "resolved": "https://registry.npmmirror.com/openpgp/-/openpgp-6.2.2.tgz",
      "integrity": "sha512-P/dyEqQ3gfwOCo+xsqffzXjmUhGn4AZTOJ1LCcN21S23vAk+EAvMJOQTsb/C8krL6GjOSBxqGYckhik7+hneNw==",
      "license": "LGPL-3.0+",
      "engines": {
        "node": ">= 18.0.0"
      }
    },
    "node_modules/prebuild-install": {
      "version": "7.1.3",
      "resolved": "https://registry.npmmirror.com/prebuild-install/-/prebuild-install-7.1.3.tgz",
      "integrity": "sha512-8Mf2cbV7x1cXPUILADGI3wuhfqWvtiLA1iclTDbFRZkgRQS0NqsPZphna9V+HyTEadheuPmjaJMsbzKQFOzLug==",
      "license": "MIT",
      "dependencies": {
        "detect-libc": "^2.0.0",
        "expand-template": "^2.0.3",
        "github-from-package": "0.0.0",
        "minimist": "^1.2.3",
        "mkdirp-classic": "^0.5.3",
        "napi-build-utils": "^2.0.0",
        "node-abi": "^3.3.0",
        "pump": "^3.0.0",
        "rc": "^1.2.7",
        "simple-get": "^4.0.0",
        "tar-fs": "^2.0.0",
        "tunnel-agent": "^0.6.0"
      },
      "bin": {
        "prebuild-install": "bin.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/pump": {
      "version": "3.0.3",
      "resolved": "https://registry.npmmirror.com/pump/-/pump-3.0.3.tgz",
      "integrity": "sha512-todwxLMY7/heScKmntwQG8CXVkWUOdYxIvY2s0VWAAMh/nd8SoYiRaKjlr7+iCs984f2P8zvrfWcDDYVb73NfA==",
      "license": "MIT",
      "dependencies": {
        "end-of-stream": "^1.1.0",
        "once": "^1.3.1"
      }
    },
    "node_modules/rc": {
      "version": "1.2.8",
      "resolved": "https://registry.npmmirror.com/rc/-/rc-1.2.8.tgz",
      "integrity": "sha512-y3bGgqKj3QBdxLbLkomlohkvsA8gdAiUQlSBJnBhfn+BPxg4bc62d8TcBW15wavDfgexCgccckhcZvywyQYPOw==",
      "license": "(BSD-2-Clause OR MIT OR Apache-2.0)",
      "dependencies": {
        "deep-extend": "^0.6.0",
        "ini": "~1.3.0",
        "minimist": "^1.2.0",
        "strip-json-comments": "~2.0.1"
      },
      "bin": {
        "rc": "cli.js"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmmirror.com/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmmirror.com/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmmirror.com/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/simple-concat": {
      "version": "1.0.1",
      "resolved": "https://registry.npmmirror.com/simple-concat/-/simple-concat-1.0.1.tgz",
      "integrity": "sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/simple-get": {
      "version": "4.0.1",
      "resolved": "https://registry.npmmirror.com/simple-get/-/simple-get-4.0.1.tgz",
      "integrity": "sha512-brv7p5WgH0jmQJr1ZDDfKDOSeWWg+OVypG99A/5vYGPqJ6pxiaHLy8nxtFjBA7oMa01ebA9gfh1uMCFqOuXxvA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "decompress-response": "^6.0.0",
        "once": "^1.3.1",
        "simple-concat": "^1.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmmirror.com/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmmirror.com/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/tar-fs": {
      "version": "2.1.4",
      "resolved": "https://registry.npmmirror.com/tar-fs/-/tar-fs-2.1.4.tgz",
      "integrity": "sha512-mDAjwmZdh7LTT6pNleZ05Yt65HC3E+NiQzl672vQG38jIrehtJk/J3mNwIg+vShQPcLF/LV7CMnDW6vjj6sfYQ==",
      "license": "MIT",
      "dependencies": {
        "chownr": "^1.1.1",
        "mkdirp-classic": "^0.5.2",
        "pump": "^3.0.0",
        "tar-stream": "^2.1.4"
      }
    },
    "node_modules/tar-stream": {
      "version": "2.2.0",
      "resolved": "https://registry.npmmirror.com/tar-stream/-/tar-stream-2.2.0.tgz",
      "integrity": "sha512-ujeqbceABgwMZxEJnk2HDY2DlnUZ+9oEcb1KzTVfYHio0UE6dG71n60d8D2I4qNvleWrrXpmjpt7vZeF1LnMZQ==",
      "license": "MIT",
      "dependencies": {
        "bl": "^4.0.3",
        "end-of-stream": "^1.4.1",
        "fs-constants": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^3.1.1"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/tunnel-agent": {
      "version": "0.6.0",
      "resolved": "https://registry.npmmirror.com/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
      "integrity": "sha512-McnNiV1l8RYeY8tBgEpuodCC1mLUdbSN+CYBL7kJsJNInOP8UjDDEwdk6Mw60vdLLrr5NHKZhMAOSrR2NZuQ+w==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/undici-types": {
      "version": "7.12.0",
      "resolved": "https://registry.npmmirror.com/undici-types/-/undici-types-7.12.0.tgz",
      "integrity": "sha512-goOacqME2GYyOZZfb5Lgtu+1IDmAlAEu5xnD3+xTzS10hT0vzpf0SPjkXwAw9Jm+4n/mQGDP3LO8CPbYROeBfQ==",
      "license": "MIT"
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmmirror.com/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    }
  }
}


---
./package.json
---
{
  "name": "granite-blockchain-mvp",
  "version": "0.0.1",
  "description": "Simple Implementation of the granite blockchain",
  "license": "ISC",
  "author": "Samuel Ayibatarri",
  "type": "commonjs",
  "main": "dist/main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.13",
    "@types/crypto-js": "^4.2.2",
    "@types/node": "^24.5.2"
  },
  "dependencies": {
    "@hono/node-server": "^1.19.5",
    "@types/elliptic": "^6.4.18",
    "base-x": "^5.0.1",
    "better-sqlite3": "^12.4.1",
    "bignumber.js": "^9.3.1",
    "crypto-js": "^4.2.0",
    "elliptic": "^6.6.1",
    "hono": "^4.10.2",
    "openpgp": "^6.2.2"
  }
}


---
./tsconfig.json
---
{
  "compilerOptions": {
    "module": "commonjs",            
    "outDir": "./dist",              
    "moduleResolution": "node",       
    "esModuleInterop": true,          
    "forceConsistentCasingInFileNames": true, 

    "rootDir": "./src",
    "target": "es2020",               
    "lib": ["es2020"],               
    "types": ["node"],

    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": false,   
    "isolatedModules": false,         
    "noUncheckedSideEffectImports": true, 
    "moduleDetection": "force",       
    "skipLibCheck": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  },
  "include": ["src/**/*"],            
  "exclude": ["node_modules", "dist"] 
}

---
./wallet/wallet_data.json
---
{
  "accountDetails": {
    "privateKeyHex": "f8ff9d7a59958c36be56f38dbbcbaa1b53f5b02f60054bde61d7a5bec6a31ed9",
    "address": {
      "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
      "balance": 949,
      "nonce": 650652
    }
  },
  "transactionHistory": {
    "TxIN": [],
    "TxOut": [
      {
        "sender": {
          "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
          "nonce": 650652,
          "balance": 49
        },
        "recipient": {
          "publicKeyHex": "AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
          "balance": 51,
          "nonce": 2959.9349966464183
        },
        "token": {
          "tokenId": "d",
          "name": "granite",
          "contractAddress": "s",
          "ticker": "gran",
          "totalSupply": 1000000000,
          "circulatingSupply": 10
        },
        "value": 50,
        "gasfee": 1,
        "txHash": "328179a13e26d8545eeada0106c056a9cf2a27ba6815aba1e267c5f7e9c55dac",
        "signature": {
          "r": "a83681f43feacc4965266ccdf3a20f298133c4c2312d69f3740e3517bcbfad11",
          "s": "3340e8a7ca192dc68dc739ddf23f76cd90623299f11d490948081514d90608d9"
        }
      },
      {
        "sender": {
          "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
          "nonce": 650652,
          "balance": 28
        },
        "recipient": {
          "publicKeyHex": "AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
          "balance": 21,
          "nonce": 4519.804247427403
        },
        "token": {
          "tokenId": "d",
          "name": "granite",
          "contractAddress": "s",
          "ticker": "gran",
          "totalSupply": 1000000000,
          "circulatingSupply": 10
        },
        "value": 20,
        "gasfee": 1,
        "txHash": "17c2b52a1e07c159f0257ffd97fe0935fa77fc65a6b3d781318883f62aaf500e",
        "signature": {
          "r": "c43c7ca2dff467f3cc87220ad46ece1b10212d8e3a8c4c3951281f79ada25830",
          "s": "434143669c25343da4ca330175f09eb6104bc7bceceefceb2ce6d366d7a4283f"
        }
      },
      {
        "sender": {
          "publicKeyHex": "049a68bf92a1967a3e3fc7363e8cb164c99ad08a49d914dfc736e540af1cd9481ffc19d5c04560c3361541ed1bc7c80fa41a136e6d9a848b827d274d5d3ea64c12",
          "nonce": 650652,
          "balance": 949
        },
        "recipient": {
          "publicKeyHex": "AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35",
          "balance": 51,
          "nonce": 1346.3838486778857
        },
        "token": {
          "tokenId": "d",
          "name": "granite",
          "contractAddress": "s",
          "ticker": "gran",
          "totalSupply": 1000000000,
          "circulatingSupply": 10
        },
        "value": 50,
        "gasfee": 1,
        "txHash": "3bc23591e99b33c526f1403aee081a2fb771ad7c4758d69ebe84d9808ebd65a2",
        "signature": {
          "r": "1291505327ca0bc8f1b17c2bc07b0b2559a3769b1301bed9111d5b4ff6b2dbd2",
          "s": "7563874100cd39272cc1a9ae4dc06b1be0ec23b8320a815f67dec5e6e732ea3b"
        },
        "txSecret": "7888dff662f1a04c52fd49bdb00abdea9a7ef62715675305b69ddd95450b93d0",
        "txSecretDiff": 4
      }
    ]
  }
}

---
./blockchain/blockchain.json
---
[]


---
./blockchain/unverified_blocks_pool.json
---


---
./blockchain/unverified_transactions_pool.json
---


---
./src/classes.ts
---
import type { AddressInterface, VerifiedTransaction } from "./interfaces";

export class AccountClass {
  private address: AddressClass;

  constructor(
    private readonly privateKeyHex: string,
    private readonly prefix: string,
    private readonly publicKeyHex: string,
    private balance: number,
    public readonly nonce: number,
    private readonly passKey: string
  ) {
    this.address = new AddressClass(this.publicKeyHex, this.balance, this.nonce);
  }

  // Delegateclass to Address 
  updateBalance(newBalance: number, passKey: string): void {
    if (!passKey || passKey !== this.passKey) {
      throw new Error("Incorrect Pass Key!");
    }
    this.address.updateBalance(newBalance);
    this.balance = newBalance; // Keep sync
  }

  get getAddress(): string {
    return `${this.prefix}_${this.publicKeyHex}`;
  }

  get getPublicKeyHex(): string {
    return this.publicKeyHex;
  }

  get currentBalance(): number {
    return this.balance;
  }

}

export class AddressClass {
  constructor(
    private readonly publicKeyHex: string,
    private balance: number,
    public readonly nonce: number,
  ) { }

  updateBalance(newBalance: number) {
    this.balance = newBalance;
    console.log("Balance Updated Successfully!");
  }

  get getPublicKeyHex(): string {
    return this.publicKeyHex;
  }
}

export class Block {
  public index: number;
  public hash: string;
  public previousHash: string;
  public timestamp: number;
  public difficulty: number;
  public nonce: number = Number(`${Date.now}-${Math.floor(Math.random() * 1000000)}`);
  public minterBalance: number;
  public minterAddress: AddressInterface;
  public accumulatorRoot: string;
  public transaction: VerifiedTransaction;

  constructor(index: number, hash: string, previousHash: string, timestamp: number, difficulty: number, minterBalance: number, minterAddress: AddressInterface, accumulatorRoot: string, transaction: VerifiedTransaction) {
    this.index = index;
    this.hash = hash;
    this.previousHash = previousHash;
    this.timestamp = timestamp;
    this.difficulty = difficulty;
    this.minterBalance = minterBalance;
    this.minterAddress = minterAddress;
    this.accumulatorRoot = accumulatorRoot;
    this.transaction = transaction;
  }
}




---
./src/constants.ts
---
import type { Token } from "./interfaces";
/// :::::::::::::::::: Paths :::::::::::::::::::::::

export const WALLET_PATH: string = "wallet/wallet_data.json";
export const BLOCKCHAIN_PATH: string = "blockchain/blockchain.json";
export const UNVERIFIED_BLOCKS_PATH: string = "blockchain/unverified_blocks_pool.json";
export const UNVERIFIED_TRANSACTIONS_PATH: string = "blockchain/unverified_transactions_pool.json";

/// :::::::::::::::::: Values ::::::::::::::::::::::
export const BASE62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

export const NATIVE_TOKEN: Token = {
  tokenId: 'd',
  name: 'granite',
  contractAddress: 's',
  ticker: 'gran',
  totalSupply: 1000000000, // 100 Million Native Tokens
  circulatingSupply: 10 // 10 Native Tokens in supply, the balance of the genesis sender and genesis receiver.
};




---
./src/data.ts
---
import { NATIVE_TOKEN } from './constants'
import type { AddressInterface, Transaction, TransactionData } from './interfaces'

export const genesisSender: AddressInterface = {
  publicKeyHex: 'AD_6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b',
  balance: 1,
  nonce: Math.random() * 10000
}

export const genesisReciever: AddressInterface = {
  publicKeyHex: 'AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35',
  balance: 1,
  nonce: Math.random() * 10000
}

export const genesisTx: Transaction<AddressInterface> = {
  sender: genesisSender,
  recipient: genesisReciever,
  token: NATIVE_TOKEN,
  value: 1,
  gasfee: 1,
  txHash: '',
  signature: { r: '', s: '' },
  txSecret: '8028f4ecd6da3344822baec652d52977973892f8766a6f78a8870f78c24ded51',
  txSecretDiff: 8,
  nonce: 120
}

export const mockTransactionData: TransactionData = [
  genesisTx,
  {
    sender: { publicKeyHex: 'AD_a1b2c3d4e5f6', balance: 100, nonce: 123 },
    recipient: { publicKeyHex: 'AD_f6e5d4c3b2a1', balance: 50, nonce: 456 },
    token: NATIVE_TOKEN,
    value: 25,
    gasfee: 1,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: '11aa22bb33cc44dd55ee66ff77gg88hh',
    txSecretDiff: 5,
    nonce: 344
  },
  {
    sender: { publicKeyHex: 'AD_abcdef123456', balance: 500, nonce: 789 },
    recipient: { publicKeyHex: 'AD_654321fedcba', balance: 300, nonce: 321 },
    token: NATIVE_TOKEN,
    value: 40,
    gasfee: 2,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: '99887766554433221100ffeeccbbddaa',
    txSecretDiff: 9,
    nonce: 123
  },
  {
    sender: { publicKeyHex: 'AD_111122223333', balance: 250, nonce: 987 },
    recipient: { publicKeyHex: 'AD_999988887777', balance: 150, nonce: 654 },
    token: NATIVE_TOKEN,
    value: 10,
    gasfee: 1,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: 'aabbccddeeff00112233445566778899',
    txSecretDiff: 3,
    nonce: 890
  },
  {
    sender: { publicKeyHex: 'AD_ff00ee11dd22', balance: 75, nonce: 222 },
    recipient: { publicKeyHex: 'AD_33cc44bb55aa', balance: 60, nonce: 333 },
    token: NATIVE_TOKEN,
    value: 5,
    gasfee: 1,
    txHash: '',
    signature: { r: '', s: '' },
    txSecret: '00112233445566778899aabbccddeeff',
    txSecretDiff: 7,
    nonce: 890
  }
]



---
./src/entry.ts
---
// main.ts (or your main server entry point)
import { serve } from '@hono/node-server';
import app from './server'; 

const port = 3000;
console.log(`Hono server running on http://localhost:${port}`);

serve({
  fetch: app.fetch, 
  port,
});

---
./src/interfaces.ts
---
import type { AccountClass, AddressClass } from './classes.ts'

export interface AddressInterface {
  readonly publicKeyHex: string;
  readonly balance: number;
  readonly nonce: number;
}

export interface WalletData {
  readonly accountDetails: AccountInterface<AddressInterface>;
  readonly transactionHistory: {
    TxIN: Transaction[];
    TxOut: Transaction[];
  }
}

export interface UnverifiedTransactionPoolInterface {
  pool: Transaction[];
}

export interface Block {
  readonly prevBlockHash: string;
  readonly currentBlockHash: string;
  readonly blockIndex: number;
  readonly blockHash: string;
  readonly transaction: VerifiedTransaction<AddressInterface>; /// Just one transaction per block to reduce complexity
  readonly timestamp: number;
  readonly validator: string;
  readonly accumulatorRoot: string;
  readonly difficulty: number;
}

export interface blockchainState {
  readonly chainLength: number;
  readonly chainSize: number;
  readonly nativeToken: Token;
  readonly cumulativeDifficulty: number;
}


export interface Blockchain {
  readonly blocks: Block[];
  readonly stateRoot: string;
  readonly state: blockchainState;
}


export interface AccountInterface<T = AddressClass | AddressInterface> {
  readonly privateKeyHex: string;
  readonly address: T;
}

export interface Transaction<Taddress = AddressClass | AddressInterface> {
  readonly nonce: number;
  readonly sender: Taddress;
  readonly recipient: Taddress;
  readonly token: Token;
  readonly value: number;
  readonly gasfee: number;
  readonly txHash: string;
  readonly signature: Signature;
  readonly txSecret: string;
  readonly txSecretDiff: number;
}

export interface VerifiedTransaction<Taddress = AddressClass | AddressInterface> {
  readonly nonce: number;
  readonly sender: Taddress;
  readonly recipient: Taddress;
  readonly token: Token;
  readonly value: number;
  readonly gasfee: number;
  readonly txHash: string;
  readonly signature: Signature;
  readonly txSecret: string;
  readonly txSecretDiff: number;
  readonly blockIndex: number;
}

export interface Token {
  readonly tokenId: string;
  readonly name: string;
  readonly contractAddress: string;
  readonly ticker: string;
  readonly totalSupply: number;
  readonly circulatingSupply: number;
}

export interface Signature {
  r: string;
  s: string;
}


---
./src/main.ts
---
// import CryptoJS from 'crypto-js';
import { createHash } from 'node:crypto';
import { genesisReciever, genesisSender, genesisTx, mockTransactionData } from './data.js';
import { diff } from 'node:util';
import * as Util from './util'
import BigNumber from 'bignumber.js';
import CryptoJS from 'crypto-js';
import { ec } from 'elliptic';
import type { Signature, Transaction, Token, AddressInterface, VerifiedTransaction } from './interfaces.ts'
import { AddressClass, AccountClass, Block } from './classes';
import { create } from 'node:domain';
import { getUnverifiedTransactionPool, selectRandomTransaction } from './transactionPool.js';
import { guessTxnSecret } from './wallet.js';

// CONSTANTS

const BLOCK_GENERATION_INTERVAL: number = 60; // Seconds

const DIFFICULTY_ADJUSTMENT_INTERVAL: number = 100 // Blocks

const NATIVE_TOKEN: Token = {
  tokenId: 'd',
  name: 'granite',
  contractAddress: 's',
  ticker: 'gran',
  totalSupply: 1000000000, // 100 Million Native Tokens
  circulatingSupply: 10 // 10 Native Tokens in supply, the balance of the genesis sender and genesis receiver.
};

// Initializing elliptic curve using secp256k 1
const ellipticCurve = new ec('secp256k1');

const genesisBlock: Block = new Block(0, 'aeebad4a796fcc2e15dc4c6061b45ed9b373f26adfc798ca7d2d8cc58182718e', 'null', 1465154705, 1, 1, genesisSender, 'accumulator', mockTransactionData[0]);

const calculateHash = (
  index: number,
  previousHash: string,
  timestamp: number,
  difficulty: number,
  minterAddress: AddressInterface,
  minterBalance: number,
  data: Transaction
): string => {
  const dataHash = data.txHash;
  return createHash('sha256')
    .update(index + previousHash + timestamp + dataHash + difficulty + minterBalance + minterAddress.publicKeyHex)
    .digest('hex');
};

const calculateHashForBlock = (block: Block): string => {
  const hash = calculateHash(block.index, block.previousHash, block.timestamp, block.difficulty, block.minterAddress, block.minterBalance, block.data[0]); /// -> For now the block hash is calculated only using the first transaction just to deal with any errors for now
  return hash;
}

// This function does nothing for now
function getLatestBlock(): Block {
  const randomTransaction: Transaction<AddressInterface> = {
    sender: {
      publicKeyHex: "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
      balance: 3.75,
      nonce: 4
    },
    recipient: {
      publicKeyHex: "3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy",
      balance: 12.89,
      nonce: 6
    },
    token: NATIVE_TOKEN,
    value: 0.15,
    gasfee: 0.0021,
    txHash: "0x4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6",
    signature: { r: '', s: '' },
    txSecret: "8028f4ecd6da3344822baec652d52977973892f8766a6f78a8870f78c24ded51",
    txSecretDiff: 8,
    nonce: 432
  }
  const randomBlock = new Block(5, '', '', 89, 1, 1, genesisSender, 'accumulator', mockTransactionData)
  return randomBlock;
}

const generateNextBlock = (blockData: Transaction): Block => {
  const previousBlock: Block = getLatestBlock();
  const nextIndex: number = previousBlock.index + 1;
  const nextTimestamp: number = new Date().getTime() / 1000;
  const nextHash: string = calculateHash(nextIndex, previousBlock.hash, nextTimestamp, 7, genesisSender, genesisSender.balance, blockData); /// Don't forget to change later, also modify the calculateHash function
  const newBlock: Block = new Block(nextIndex, nextHash, previousBlock.hash, nextTimestamp, 7, genesisSender.balance, genesisSender, "root", blockData);
  return newBlock;
}

// Block chain would be stored in an array for now
let blockchain: Block[] = [genesisBlock];

const isValidNewBlock = (newBlock: Block, previousBlock: Block): boolean => {

  if (previousBlock.index + 1 !== newBlock.index) {
    console.log('Invalid Index');
    return false;
  } else if (previousBlock.hash !== newBlock.previousHash) {
    console.log('invalid previoushash');
    return false;
  } else if (calculateHashForBlock(newBlock) !== newBlock.hash) {
    console.log(typeof (newBlock.hash) + '' + typeof calculateHashForBlock(newBlock));
    console.log('invalid hash; ' + calculateHashForBlock(newBlock) + '' + newBlock.hash);
    return false;
  }
  return true;
};


const isValidChain = (blockchainToValidate: Block[]): boolean => {
  const isValidGenesis = (block: Block | undefined): boolean => {
    if (!block) return false;
    return JSON.stringify(block) === JSON.stringify(genesisBlock);
  };

  if (!isValidGenesis(blockchainToValidate[0])) {
    return false;
  }

  for (let i = 1; i < blockchainToValidate.length; i++) {
    const currentBlock = blockchainToValidate[i];
    const prevBlock = blockchainToValidate[i - 1];

    if (!currentBlock || !prevBlock) return false;

    if (!isValidNewBlock(currentBlock, prevBlock)) {
      return false;
    }
  }

  return true;
};


// const replaceChain = (newBlocks: Block[]) => {
//     if (isValidChain(newBlocks) && newBlocks.length > getBlockchain().length) {
//         console.log('Recieved blockchain is valid. Replacing current blockchain with received blockchain');
//         blockchain = newBlocks;
//         broadcastLatest();
//     } else {
//         console.log('Received blockchain is invalid');
//     }
// }

const getCurrentTimestamp = (): number => {
  let latestBlock: Block = blockchain[blockchain.length - 1]!;
  return latestBlock.timestamp;
}

// const findBlock = (index: number, previousHash: string, data: Transaction | NFT, difficulty: number ): Block => {
//     let pastTimestamp: number = 0;
//     while (true) {
//         let timestamp: number = getCurrentTimestamp();
//         if(pastTimestamp !== timestamp) {
//             let hash: string = calculateHash(index, previousHash, timestamp, difficulty, getPublicFromWallet(), getAccountBalance(), data);
//             if (isBlockStakingValid(previousHash, getPublicFromWallet(), timestamp, getAccountBalance(), difficulty, index)) {
//                 return new Block(index, hash, previousHash, timestamp, difficulty, getAccountBalance(), getPublicFromWallet(), data);
//             }
//             pastTimestamp = timestamp; 
//         }
//     }
// };

const getDifficulty = (blockchain: Block[]): number => {
  if (!blockchain || blockchain.length === 0) {
    return -1; // or throw new Error("Blockchain is empty")
  }

  const latestBlock = blockchain[blockchain.length - 1]!; // always defined now

  if (latestBlock.index % DIFFICULTY_ADJUSTMENT_INTERVAL === 0 && latestBlock.index !== 0) {
    return getAdjustedDifficulty(latestBlock, blockchain);
  } else {
    return latestBlock.difficulty;
  }
};


const getAdjustedDifficulty = (latestBlock: Block, blockchain: Block[]): number => {
  const prevAdjustmentBlock: Block = blockchain[blockchain.length - DIFFICULTY_ADJUSTMENT_INTERVAL]!;
  const timeExpected: number = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;
  const timeTaken: number = latestBlock.timestamp - prevAdjustmentBlock.timestamp;
  if (timeTaken < timeExpected / 2) {
    return prevAdjustmentBlock.difficulty + 1;
  } else if (timeTaken > timeExpected * 2) {
    return prevAdjustmentBlock.difficulty - 1;
  } else {
    return prevAdjustmentBlock.difficulty
  }
};

const signTx = (txHash: string, privKeyHex: string): Signature => {
  const key = ellipticCurve.keyFromPrivate(privKeyHex, 'hex');
  const signature = key.sign(txHash, { canonical: true });

  return {
    r: signature.r.toString(16),
    s: signature.s.toString(16),
  };
};

const verifyTxSignature = (txHash: string, publicKeyHex: string, signature: { r: string, s: string }): boolean => {
  const key = ellipticCurve.keyFromPublic(publicKeyHex, 'hex');
  return key.verify(txHash, signature);
};

const verifyTxHash = (transaction: Transaction<AddressInterface>): boolean => {
  let storedTxHash: string = transaction.txHash;
  let calculatedTxHash: string = calculateHashForTransaction(transaction.sender, transaction.recipient, transaction.token, transaction.value, transaction.gasfee);
  return storedTxHash === calculatedTxHash;
}

const calculateHashForTransaction = (sender: AddressInterface, recipient: AddressInterface, token: Token, value: number, gasfee: number): string => {
  const result: string = createHash('sha256').update(sender.publicKeyHex + recipient.publicKeyHex + token.tokenId + value + gasfee).digest('hex');
  return result;
}

/// Verify Transaction
const verifyTx = (transaction: Transaction<AddressInterface>): boolean => {
  if (!verifyTxHash(transaction) || !verifyTxSignature(transaction.txHash, transaction.sender.publicKeyHex, transaction.signature)) {
    return false;
  };

  const userBalanceFromLocalDB = Util.getUserBalanceFromLocalBC(transaction.sender.publicKeyHex);
  if (userBalanceFromLocalDB < (transaction.value + transaction.gasfee)) return false;

  return true
}

/// Mint a block
const mintBlock = async (): Promise<Block> => {
  const pool = getUnverifiedTransactionPool();
  const transaction = selectRandomTransaction(1, pool) as Transaction<AddressInterface>;

  if (!verifyTx(transaction)) throw new Error("Invalid Transaction selected from pool");

  const guessedTxnSecret = await guessTxnSecret(transaction.txSecretDiff, transaction.txSecret);

  const prevBlock = getLatestBlock();
  const nextIndex = prevBlock.index + 1;
  const timestamp = Date.now() / 1000;

  const verifiedTransaction: VerifiedTransaction = {
    ...transaction,
    blockIndex: nextIndex
  };

  const minerAddress = genesisSender; /// Should be the current node address not miner, I'll add the update later
  const minerBalance = Util.getUserBalanceFromLocalBC(minerAddress.publicKeyHex);

  const hash = calculateHash(
    nextIndex,
    prevBlock.hash,
    timestamp,
    7, /// Difficulty (hardcoded for now, it should be the same value as transaction difficulty)
    minerAddress,
    minerBalance,
    verifiedTransaction
  );

  const newBlock = new Block(
    nextIndex,
    hash,
    prevBlock.hash,
    timestamp,
    7,
    minerBalance,
    minerAddress,
    "accumulator-placeholder", /// I'll have to change this since I won't be using the accumulator for this mvp
    verifiedTransaction
  );

  return newBlock;
}


---
./src/polynomial_accumulator.ts
---
interface Proof {
    coef_1: bigint;
    coef_2: bigint;
    coef_3: bigint;
    coef_4: bigint;
    coef_5: bigint;
}

type Params = [bigint, bigint, bigint, bigint, bigint];

export function createProof(arg: Params): Proof {
    const argSet = new Set(arg);
    if (argSet.size !== arg.length) throw new Error("All params must be unique!");
    const [a, b, c, d, e] = arg;
    if (a.toString().length !== 5 || b.toString().length !== 5 || c.toString().length !== 5 || d.toString().length !== 5 || e.toString().length !== 5 ) {
        throw new Error("All parameters must be 5 numbers long!");
    }
    
    const proof: Proof = {
        coef_1: a + b + c + d + e,
        coef_2: a*b + a*c + a*d + a*e + b*c + b*d + b*e + c*d + c*e + d*e,
        coef_3: a*b*c + a*b*d + a*b*e + a*c*d + a*c*e + a*d*e + b*c*d + b*c*e + b*d*e + c*d*e,
        coef_4: a*b*c*d + a*b*c*e + a*b*d*e + a*c*d*e + b*c*d*e,
        coef_5: a*b*c*d*e
    };
    console.log("This is the length of the first string: ", a.toString().length)
    return proof;
}

export function verifyRoot(proof: Proof, originalParam: bigint): boolean {
    const root = -originalParam;
    const result = 
        (root ** 5n) + 
        (proof.coef_1 * (root ** 4n)) + 
        (proof.coef_2 * (root ** 3n)) + 
        (proof.coef_3 * (root ** 2n)) + 
        (proof.coef_4 * root) + 
        proof.coef_5;
    return result === 0n; 
}

const myParams: Params = [12375n, 27987n, 37438n, 47487n, 57986n];

const myProof = createProof(myParams);
console.log("Proof (Coefficients):", myProof);

console.log("--- Verifying Correct Roots ---");
console.log("Verifying root for param 1235n:", verifyRoot(myProof, 12375n));
console.log("Verifying root for param 2987n:", verifyRoot(myProof, 27987n));
console.log("Verifying root for param 3438n:", verifyRoot(myProof, 37438n));
console.log("Verifying root for param 4487n:", verifyRoot(myProof, 47487n));
console.log("Verifying root for param 5986n:", verifyRoot(myProof, 57986n));

console.log("--- Verifying Incorrect Root ---");
console.log("Verifying non-root (testing -7n):", verifyRoot(myProof, 7n));

---
./src/server.ts
---
import { Hono } from 'hono';

const app = new Hono();

/// :::::::::::::: Blockchain Network Endpoints :::::::::::::::::

/// get blockchain
app.get('/blocks', async (c) => {
    
});

/// get user transaction history 
app.get('/transactions', async (c) => {
    
});

/// mint a block
app.post('/mintBlock', async (c) => {

});

/// mint a transaction
app.post('/mintTransaction', async (c) => {

})

export default app;

// const initHttpServer = ( myHttpPort: number ) => {
//     const app = express();
//     app.use(bodyParser.json());

//     app.get('/blocks', (req, res) => {
//         res.send(getBlockchain());
//     });
//     app.post('/mintBlock', (req, res) => {
//         const newBlock: Block = generateNextBlock(req.body.data);
//         res.send(newBlock);
//     });
//     app.get('/peers', (req, res) => {
//         res.send(getSockets().map(( s: any ) => s._socket.remoteAddress + ':' + s._socket.remotePort));
//     });
//     app.post('/addPeer', (req, res) => {
//         connectToPeers(req.body.peer);
//         res.send();
//     });

//     app.listen(myHttpPort, () => {
//         console.log('Listening http on port: ' + myHttpPort);
//     });
// };

---
./src/transactionPool.ts
---
import type * as Interfaces from "./interfaces.ts"
import { readFile } from "./util"
import { UNVERIFIED_TRANSACTIONS_PATH } from "./constants.js";

export function getUnverifiedTransactionPool(): Interfaces.Transaction<Interfaces.AddressInterface>[] {
  const data = readFile(UNVERIFIED_TRANSACTIONS_PATH) as Interfaces.UnverifiedTransactionPoolInterface;
  if (!data) throw new Error("An error occured");
  return data.pool as Interfaces.Transaction<Interfaces.AddressInterface>[];
};

export function selectRandomTransaction(n: number = 1, transactionData: Interfaces.Transaction<Interfaces.AddressInterface>[]): Interfaces.Transaction<Interfaces.AddressInterface> { /// -> This function should only select just one transaction by default
  if (transactionData.length === 0) throw new Error("There's nothing in the transaction data");
  if (n < 1) throw new Error("Pick a valid number!");
  const randomIndex = Math.floor(Math.random() * transactionData.length);
  const result: Interfaces.Transaction<Interfaces.AddressInterface> = transactionData[randomIndex] as Interfaces.Transaction<Interfaces.AddressInterface>;
  return result
}


---
./src/util.ts
---
import { readFileSync, writeFileSync, existsSync, statSync } from 'fs';
import * as Interfaces from './interfaces';
import { createHash, randomBytes } from 'node:crypto';
import { ec } from 'elliptic'
import * as CONSTANTS from './constants'
import { Block } from './interfaces';

const ellipticCurve = new ec('secp256k1');

/// Read data from a file
export function readFile(filePath: string): Interfaces.WalletData | Interfaces.UnverifiedTransactionPoolInterface | Interfaces.Block[] {
  let data: string;
  try {
    data = readFileSync(filePath, 'utf-8');
  } catch (error) {
    console.error("Error reading file: ", error);
    throw error;
  }
  return JSON.parse(data)
}

/// Sign transactions

export const signTx = (txHash: string, privKeyHex: string): Interfaces.Signature => {
  const key = ellipticCurve.keyFromPrivate(privKeyHex, 'hex');
  const signature = key.sign(txHash, { canonical: true });

  return {
    r: signature.r.toString(16),
    s: signature.s.toString(16),
  };
};

const calculateHashForTransaction = (sender: Interfaces.AddressInterface, recipient: Interfaces.AddressInterface, token: Interfaces.Token, value: number, gasfee: number): string => {
  const result: string = createHash('sha256').update(sender.publicKeyHex + sender.balance + recipient.publicKeyHex + recipient.balance + token.tokenId + value + gasfee).digest('hex');
  return result;
}

const verifyTxHash = (transaction: Interfaces.Transaction<Interfaces.AddressInterface>): boolean => {
  let storedTxHash: string = transaction.txHash;
  let calculatedTxHash: string = calculateHashForTransaction(transaction.sender, transaction.recipient, transaction.token, transaction.value, transaction.gasfee);
  return storedTxHash === calculatedTxHash;
}

/// Write to a file
function writeFile(filePath: string, data: object): void {
  const sData = JSON.stringify(data, null, 2);
  try {
    writeFileSync(filePath, sData, 'utf-8');
  } catch (error) {
    console.error("Error writing file: ", error);
    throw error
  }
}


/// Check if a file exists
function checkIfFileExists(filePath: string): boolean {
  try {
    return existsSync(filePath) && statSync(filePath).isFile();
  } catch (error) {
    return false
  }
}

/// Check if file is empty
function checkIfFileIsEmpty(filePath: string): boolean {
  if (checkIfFileExists(filePath)) {
    const fileData = readFile(filePath);
    if (Object.keys(fileData).length === 0) {
      return true;
    }
  }
  return false
}

/// Generate key pair
const genKeyPair = (): { privKey: string, pubKey: string } => {
  const keyPair = ellipticCurve.genKeyPair();
  const privateKey = keyPair.getPrivate('hex');
  const publicKey = keyPair.getPublic('hex');

  return {
    privKey: privateKey,
    pubKey: publicKey
  }
}

function genUniqueNonce(): number {
  const timestamp = Date.now();
  const timestampPart = timestamp % 1000000;
  const randomNumber = randomBytes(2).readUInt16BE(0);

  return timestampPart + randomNumber;
}

export const getUserBalanceFromLocalBC = (senderPublicKeyHex: string): number => {
  if (!checkIfFileExists(CONSTANTS.BLOCKCHAIN_PATH)) throw new Error("Block chain file doesn't exist");
  const blockchain: Block[] = readFile(CONSTANTS.BLOCKCHAIN_PATH) as Block[];
  if (blockchain.length === 0) throw new Error("The blockchain is empty")
  let balance = 0;
  blockchain.forEach(block => {
    const tx = block.transaction;

    if (tx.recipient.publicKeyHex === senderPublicKeyHex) {
      balance += tx.value;
    }

    if (tx.sender.publicKeyHex === senderPublicKeyHex) {
      balance -= (tx.value + tx.gasfee);
    }
  });
  return balance;
}


---
./src/wallet.ts
---
import CryptoJS from 'crypto-js';
import { createHash, randomBytes } from 'node:crypto';
import crypto from 'crypto';
import { ec } from 'elliptic';
import type { AccountInterface, AddressInterface, Transaction, Token, Signature, WalletData } from './interfaces.ts';
import { AccountClass, AddressClass } from './classes.js';
import { readFileSync, writeFileSync, existsSync, statSync } from 'fs';
import * as path from 'path';
import { read } from 'node:fs';
import baseX from 'base-x'
import { WALLET_PATH, BLOCKCHAIN_PATH, BASE62 } from './constants.js'
const ellipticCurve = new ec('secp256k1');

/// CONSTANTS 

const DEFAULT_BALANCE: number = 0;
const MAX_DIFFICULTY: 16 = 16;
const MIN_DIFFICULTY: 4 = 4;
const CURRENT_DIFFICULTY: number = 4
const GAS_FEE: number = 1;
const NATIVE_TOKEN: Token = {
  tokenId: 'd',
  name: 'granite',
  contractAddress: 's',
  ticker: 'gran',
  totalSupply: 1000000000, // 100 Million Native Tokens
  circulatingSupply: 10 // 10 Native Tokens in supply, the balance of the genesis sender and genesis receiver.
};
const testReciever: AddressInterface = {
  publicKeyHex: 'AD_d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35',
  balance: 1,
  nonce: Math.random() * 10000 // Don't forget to change later
};

/// Read data from a file
export function readFile(filePath: string): WalletData {
  let data: string;
  try {
    data = readFileSync(filePath, 'utf-8');
  } catch (error) {
    console.error("Error reading file: ", error);
    throw error;
  }
  return JSON.parse(data)
}

/// Sign transactions

const signTx = (txHash: string, privKeyHex: string): Signature => {
  const key = ellipticCurve.keyFromPrivate(privKeyHex, 'hex');
  const signature = key.sign(txHash, { canonical: true });

  return {
    r: signature.r.toString(16),
    s: signature.s.toString(16),
  };
};

const calculateHashForTransaction = (sender: AddressInterface, recipient: AddressInterface, token: Token, value: number, gasfee: number): string => {
  const result: string = createHash('sha256').update(sender.publicKeyHex + sender.balance + recipient.publicKeyHex + recipient.balance + token.tokenId + value + gasfee).digest('hex');
  return result;
}

const verifyTxHash = (transaction: Transaction<AddressInterface>): boolean => {
  let storedTxHash: string = transaction.txHash;
  let calculatedTxHash: string = calculateHashForTransaction(transaction.sender, transaction.recipient, transaction.token, transaction.value, transaction.gasfee);
  return storedTxHash === calculatedTxHash;
}

/// Write to a file
function writeFile(filePath: string, data: object): void {
  const sData = JSON.stringify(data, null, 2);
  try {
    writeFileSync(filePath, sData, 'utf-8');
  } catch (error) {
    console.error("Error writing file: ", error);
    throw error
  }
}


/// Check if a file exists
function checkIfFileExists(filePath: string): boolean {
  try {
    return existsSync(filePath) && statSync(filePath).isFile();
  } catch (error) {
    return false
  }
}

/// Check if file is empty
function checkIfFileIsEmpty(filePath: string): boolean {
  if (checkIfFileExists(filePath)) {
    const fileData = readFile(filePath);
    if (Object.keys(fileData).length === 0) {
      return true;
    }
  }
  return false
}

/// Generate key pair
const genKeyPair = (): { privKey: string, pubKey: string } => {
  const keyPair = ellipticCurve.genKeyPair();
  const privateKey = keyPair.getPrivate('hex');
  const publicKey = keyPair.getPublic('hex');

  return {
    privKey: privateKey,
    pubKey: publicKey
  }
}

function genUniqueNonce(): number {
  const timestamp = Date.now();
  const timestampPart = timestamp % 1000000;
  const randomNumber = randomBytes(2).readUInt16BE(0);

  return timestampPart + randomNumber;
}

function genWallet(): WalletData {
  const hexKeyPair = genKeyPair();
  const wallet_data: WalletData = {
    accountDetails: {
      privateKeyHex: hexKeyPair.privKey,
      address: {
        publicKeyHex: hexKeyPair.pubKey,
        balance: DEFAULT_BALANCE,
        nonce: genUniqueNonce()
      }
    },
    transactionHistory: {
      TxIN: [],
      TxOut: []
    }
  }

  return wallet_data;
}

function createWallet() {
  const fileExists: boolean = checkIfFileExists(WALLET_PATH);
  const fileIsEmpty: boolean = checkIfFileIsEmpty(WALLET_PATH);
  if (!fileExists || fileIsEmpty) {
    writeFile(WALLET_PATH, genWallet());
    console.log("Wallet created successfully")
    return;
  }
  console.error("Wallet could not be created because it already exists!")
  return;
}

function makeTransaction(recipientAddr: AddressInterface, amountToSend: number,): Transaction<AddressInterface> {
  const wallet_data = readFile(WALLET_PATH);
  if (wallet_data.accountDetails.address.balance < amountToSend) {
    throw new Error(`You don't have enough ${NATIVE_TOKEN.name} to make this transaction`)
  }
  const newSenderBalance = wallet_data.accountDetails.address.balance - amountToSend - GAS_FEE;
  const newReceiverBalance = recipientAddr.balance + amountToSend;
  const transactionHash = calculateHashForTransaction(wallet_data.accountDetails.address, recipientAddr, NATIVE_TOKEN, amountToSend, GAS_FEE);
  const transactionSignature = signTx(transactionHash, wallet_data.accountDetails.privateKeyHex);
  const transaction: Transaction<AddressInterface> = {
    sender: {
      publicKeyHex: wallet_data.accountDetails.address.publicKeyHex,
      nonce: wallet_data.accountDetails.address.nonce,
      balance: newSenderBalance
    },
    recipient: {
      publicKeyHex: recipientAddr.publicKeyHex,
      balance: newReceiverBalance,
      nonce: recipientAddr.nonce
    },
    token: NATIVE_TOKEN,
    value: amountToSend,
    gasfee: GAS_FEE,
    txHash: transactionHash,
    signature: transactionSignature,
    txSecret: generateTxnSecret(CURRENT_DIFFICULTY),
    txSecretDiff: CURRENT_DIFFICULTY,
    nonce: 789
  }

  const wallet_data_class = new AddressClass(wallet_data.accountDetails.address.publicKeyHex, wallet_data.accountDetails.address.balance, wallet_data.accountDetails.address.nonce);
  wallet_data_class.updateBalance(newSenderBalance);
  const updated_wallet_data: WalletData = {
    accountDetails: {
      privateKeyHex: wallet_data.accountDetails.privateKeyHex,
      address: {
        publicKeyHex: wallet_data.accountDetails.address.publicKeyHex,
        balance: newSenderBalance,
        nonce: wallet_data.accountDetails.address.nonce
      }
    },
    transactionHistory: {
      TxIN: [...wallet_data.transactionHistory.TxIN],
      TxOut: [...wallet_data.transactionHistory.TxOut, transaction]
    }
  }

  writeFile(WALLET_PATH, updated_wallet_data)

  console.log("This is the transaction data: ", transaction);
  console.log("This is the updated wallet data: ", updated_wallet_data)
  return transaction;
}

const verifyTxSignature = (txHash: string, publicKeyHex: string, signature: { r: string, s: string }): boolean => {
  const key = ellipticCurve.keyFromPublic(publicKeyHex, 'hex');
  return key.verify(txHash, signature);
};

const verifyBalanceFromTransactionHistory = (): boolean => {
  console.log("Checking Transaction History");

  const wallet_data = readFile(WALLET_PATH);
  const wallet_balance = wallet_data.accountDetails.address.balance;

  // Verify transaction hashes
  const unverifiedTransactionsOut = (wallet_data.transactionHistory.TxOut as Transaction<AddressInterface>[]).map(_ => verifyTxHash(_)).filter(_ => _ === false);
  const unverifiedTransactionsIn = (wallet_data.transactionHistory.TxIN as Transaction<AddressInterface>[]).map(_ => verifyTxHash(_)).filter(_ => _ === false);

  if (unverifiedTransactionsIn.length > 0 || unverifiedTransactionsOut.length > 0) {
    console.error("Error: You have transactions with unverified transaction hashes and as such your entire transaction history is likely false");
    return false;
  }

  // Verify transaciton signatures
  const unverifiedTransactionsSigOut = (wallet_data.transactionHistory.TxOut as Transaction<AddressInterface>[]).map(_ => verifyTxSignature(_.txHash, _.sender.publicKeyHex, _.signature)).filter(_ => _ === false);
  const unverifiedTransactionsSigIn = (wallet_data.transactionHistory.TxIN as Transaction<AddressInterface>[]).map(_ => verifyTxSignature(_.txHash, _.sender.publicKeyHex, _.signature)).filter(_ => _ === false);

  if (unverifiedTransactionsSigIn.length > 0 || unverifiedTransactionsSigOut.length > 0) {
    console.error("Error: You have transactions with unverified transaction hashes and as such your entire transaction history is likely false");
    return false;
  }

  if (wallet_balance == 0 && wallet_data.transactionHistory.TxIN.length === 0) {
    console.error(`Error: Your wallet balance of: ${wallet_balance} ${NATIVE_TOKEN.name} doesn't correspond with your transaction history.`)
    return false;
  }

  const totalTransactionsOut = wallet_data.transactionHistory.TxOut.map(_ => _.value).reduce((sum, curr) => sum + curr, 0) + (wallet_data.transactionHistory.TxOut.length * GAS_FEE);
  const totalTransactionsIn = wallet_data.transactionHistory.TxOut.map(_ => _.value).reduce((sum, curr) => sum + curr, 0);


  if (wallet_balance !== totalTransactionsIn - totalTransactionsOut) {
    console.error(`Error: Your wallet balance of: ${wallet_balance} ${NATIVE_TOKEN} doesn't correspond with your transaction history.`)
    return false
  }

  return true;
}

const getAccountBalance = (): number | undefined => {
  const wallet_data = readFile(WALLET_PATH);
  const walletVerified = verifyBalanceFromTransactionHistory();
  if (!walletVerified) {
    console.error("Your account balance could not be verified")
    return
  }
  return wallet_data.accountDetails.address.balance
}

/// Create a secret for a transaction
export const generateTxnSecret = (difficulty: number): string => {
  const base52 = baseX(BASE62);
  if (difficulty > MAX_DIFFICULTY || difficulty < MIN_DIFFICULTY) throw new Error("Invalid difficulty");
  const trailingZeros: string = '0'.repeat((MAX_DIFFICULTY + 1) - difficulty);
  const str: string = base52.encode(randomBytes(13));
  const truncated: string = str.slice(0, difficulty);
  const secret: string = trailingZeros + truncated;
  const result: string = createHash('sha256').update(secret).digest('hex');
  console.log("Secret: ", secret);
  console.log(result);
  return result
}

/// Guess transaction secret
export const guessTxnSecret = async (difficulty: number, secretHash: string): Promise<string> => {
  if (difficulty > MAX_DIFFICULTY || difficulty < MIN_DIFFICULTY)
    throw new Error("Invalid difficulty");
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const trailingZeros = "0".repeat((MAX_DIFFICULTY + 1) - difficulty);

  while (true) {
    let s = "";
    for (let i = 0; i < difficulty; i++) {
      s += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    const secret = trailingZeros + s;
    console.log("guess: ", secret)
    const guess = createHash("sha256").update(secret).digest("hex");
    if (guess === secretHash) {
      console.log("Correct guess:", secret);
      return secret;
    }
  }
};

/// Verify transaction secret guess
const verifyTxSecret = (secretHash: string, guess: string): boolean => {
  const guessHash = createHash('sha256').update(guess).digest('hex');
  return guessHash === secretHash;
}


// verifyBalanceFromTransactionHistory();
// makeTransaction(testReciever, 50);
console.log("Is user balance correct?: ", verifyBalanceFromTransactionHistory());
// generateTxnSecret(4);
// guessTxnSecret(4,"935aee836cfee766db9a51db08046d3f721f2553a593ff92dd2466f7e682626a") /// secret to find -> 000000000000052Dq


---
